---
title: "Configure the Command Line for Data Science Development"
subtitle: "Setting up Kitty terminal, Zsh shell, and
  productivity tools for everyday data science work"
author: "Ronald G. Thomas"
date: "2026-02-16"
categories: [terminal, zsh, macos, configuration, git, neovim]
description: "I didn't really know how much time I was losing
  to default terminal settings until I sat down and configured
  Kitty and Zsh from scratch. Here's what I learned."
image: "media/images/hero.png"
document-type: "blog"
draft: false
execute:
  echo: true
  warning: false
  message: false
format:
  html:
    code-fold: false
    code-tools: false
---

![A kitty terminal emulator showing a customised prompt and colour
scheme](media/images/hero.png){.img-fluid width=80%}

*kitty with a Dracula-inspired colour scheme -- the kind of
environment this post helps you build.*

# Introduction


The configuration is opinionated. It reflects the tools I reach
for daily: R, Python, Docker, Git, and fuzzy finders. Your
workflow will differ, but the structural decisions -- how to
organise a `.zshrc`, which Kitty settings actually matter, and
how to keep the whole thing portable -- should transfer.

## Motivations

- I was spending too many keystrokes navigating between project
  directories, and `cd ../../..` chains were getting absurd.
- My default terminal had a 2,000-line scrollback buffer, which
  meant I lost model training output before I could review it.
- I had no visual indicator of which git branch I was on, leading
  to commits on the wrong branch more than once.
- Plugin installation felt like guesswork -- I wanted a
  cross-platform loading strategy that worked on both my Mac and
  my Linux server.
- I kept accumulating aliases in random places and needed a
  single, well-organised configuration file.
- I wanted Kitty's image protocol for viewing matplotlib plots
  directly in the terminal, rather than switching to a file
  manager.

## Objectives

1. Install and configure Kitty terminal with a merged
   configuration covering fonts, colours, performance, and
   data-science-specific settings.
2. Set up Zsh with a modular `.zshrc` that handles environment
   variables, history, completion, prompts, plugins, aliases, and
   custom functions in clearly separated sections.
3. Implement productivity shortcuts -- directory jumping,
   fzf-powered file finding, and safety aliases -- that reduce
   repetitive typing.
4. Configure cross-platform plugin loading so the same `.zshrc`
   works on macOS and Linux without modification.

I'm documenting my learning process here. If you spot errors or
have better approaches, please let me know.

![](media/images/terminal-logo.png){.img-fluid width=30% fig-align="center"}

*A well-configured editor and terminal working together --
the goal of this entire setup.*

# Prerequisites and Setup

This post assumes you have administrative privileges on a macOS
or Linux machine and are comfortable running commands in a
terminal. You will need:

- **macOS**: Homebrew (`brew`) installed
- **Linux**: A system package manager (apt, dnf, or pacman)
- **Both**: Git and Zsh 5.0+

**macOS installation:**

```bash
brew install kitty
```

**Linux installation:**

```bash
# Ubuntu/Debian
sudo apt-get install kitty

# Fedora/RHEL
sudo dnf install kitty

# Arch Linux
sudo pacman -S kitty
```

Kitty stores its configuration in `~/.config/kitty/kitty.conf`.
Zsh reads `~/.zshrc` at startup. Both files are plain text and
can be version-controlled in a dotfiles repository.

# What is Kitty?

Kitty is a GPU-accelerated terminal emulator written in C and
Python. Unlike traditional terminals, it offloads rendering to
the GPU, which makes scrolling through large outputs noticeably
smoother. Its main appeal for data science work is the built-in
graphics protocol: you can display images, plots, and charts
directly in the terminal window using `kitten icat` or
backend libraries like `matplotlib-backend-kitty`.

Think of Kitty as a terminal that understands pictures. Where a
standard terminal can only show text, Kitty can render a
matplotlib scatter plot inline, right below the command that
generated it.

# Getting Started: Kitty Terminal Configuration

The configuration file below is a single, merged `kitty.conf`.
I started with a basic setup and gradually added data-science
specific settings over several weeks. The comments explain the
reasoning behind each group of settings.

`~/.config/kitty/kitty.conf`:

```sh

# Kitty Configuration
# Cursor
cursor_shape block
cursor_blink_interval 0

# Scrollback
scrollback_lines 10000

# Performance
repaint_delay 10
input_delay 3
sync_to_monitor yes

# Window layout
# remember_window_size  yes
initial_window_width  1024
initial_window_height 768
window_padding_width 4

# Tab bar
tab_bar_edge bottom
tab_bar_style powerline
tab_powerline_style slanted

# Key bindings (preserving your existing ones)
map cmd+d launch --location=vsplit --cwd=current

# Additional useful key bindings
map cmd+w close_window
map cmd+shift+w close_tab
map cmd+t new_tab
map cmd+shift+] next_tab
map cmd+shift+[ previous_tab

# Tab shortcuts
map cmd+1 goto_tab 1
map cmd+2 goto_tab 2
map cmd+3 goto_tab 3
map cmd+4 goto_tab 4
map cmd+5 goto_tab 5

# Zoom
map cmd+plus change_font_size all +2.0
map cmd+minus change_font_size all -2.0
map cmd+0 change_font_size all 0
map ctrl+shift+z toggle_layout stack

# Clipboard
map cmd+c copy_to_clipboard
map cmd+v paste_from_clipboard
copy_on_select clipboard

# Miscellaneous
allow_remote_control yes
listen_on unix:/tmp/kitty
# shell_integration enabled


# =============================================================================
# DATA SCIENCE SPECIFIC CONFIGURATIONS
# =============================================================================
# Optimized settings for data scientists working with large datasets,
# visualizations, remote servers, and Jupyter notebooks
# References: https://sw.kovidgoyal.net/kitty/conf/

# SCROLLBACK CONFIGURATION FOR LARGE DATASETS
# -----------------------------------------------------------------------------
# Data scientists often work with outputs from large dataset processing,
# model training logs, and lengthy computational results that require
# extensive scrollback history for analysis and debugging.
# 
# Default scrollback_lines is 2000, but data science workflows benefit from
# much larger buffers to review:
# - Training logs from ML models (epochs, loss values, metrics)
# - Database query results and data exploration output
# - Error traces from complex data processing pipelines
# - Statistical analysis results and summary statistics
#
# Example usage: After running a pandas DataFrame.describe() on a large dataset,
# you can scroll back to compare statistics across different data subsets
# Reference: https://sw.kovidgoyal.net/kitty/conf/#scrollback-lines
scrollback_lines 50000

# SCROLLBACK PAGER FOR DATA EXPLORATION
# -----------------------------------------------------------------------------
# The scrollback pager allows opening terminal history in a full-featured
# text editor/pager for advanced search, navigation, and analysis.
# Critical for data scientists who need to:
# - Search through large model training outputs for specific metrics
# - Copy/extract specific results from lengthy computational outputs
# - Navigate complex error traces in data processing pipelines
# - Review and compare results across multiple experimental runs
#
# Press Ctrl+Shift+H to open scrollback in your pager
# Example: After running a hyperparameter search, use the pager to search
# for "best_score" or "validation_accuracy" across all output
# Reference: https://sw.kovidgoyal.net/kitty/conf/#scrollback-pager
scrollback_pager less --chop-long-lines --RAW-CONTROL-CHARS +INPUT_LINE_NUMBER

# PERFORMANCE OPTIMIZATION FOR DATA PROCESSING
# -----------------------------------------------------------------------------
# Data science workflows often involve high-throughput operations:
# - Streaming large datasets through command-line tools
# - Real-time monitoring of training processes
# - Processing CSV/JSON files with command-line utilities
# - Running intensive computational tasks
#
# These settings minimize latency and maximize throughput for such operations:
# Reference: https://sw.kovidgoyal.net/kitty/performance/

# Reduce input delay for responsive interaction during long-running processes
# Example: When monitoring training progress, you want immediate response
# when pausing/stopping processes or adjusting parameters
input_delay 0

# Minimize repaint delay for smooth data streaming visualization
# Example: When using tools like 'tail -f' to monitor log files or
# streaming data processing output in real-time
repaint_delay 2

# Disable vsync for maximum performance during data processing
# Trade-off: May cause slight screen tearing but improves performance
# for high-throughput data operations
# sync_to_monitor no

# REMOTE WORK CAPABILITIES FOR CLOUD/HPC ENVIRONMENTS
# -----------------------------------------------------------------------------
# Data scientists frequently work on remote servers, cloud instances,
# and HPC clusters where computational resources are available.
# 
# Enable remote control for programmatic terminal management:
# - Automate window/tab creation for different experiments
# - Programmatically set titles for different model runs
# - Control terminal from Jupyter notebooks or Python scripts
# Example: Set window titles to track different model experiments:
# $ kitty @ set-window-title "Model-XGBoost-Experiment-1"
# Reference: https://sw.kovidgoyal.net/kitty/remote-control/
allow_remote_control yes

# Shell integration provides enhanced features for data science workflows:
# - Jump to previous command outputs (useful for reviewing model results)
# - Enhanced command history navigation
# - Better integration with shell-based data tools
# Example: Quickly jump back to the output of a previous pandas operation
# or statistical analysis
# Reference: https://sw.kovidgoyal.net/kitty/shell-integration/
# shell_integration enabled

# FONT CONFIGURATION FOR CODE AND DATA READABILITY
# -----------------------------------------------------------------------------
# Data scientists work extensively with:
# - Python/R code with mathematical symbols
# - CSV/JSON data that requires clear column alignment
# - Statistical output with precise numeric formatting
# - Documentation and markdown files
#
# FiraCode Nerd Font provides:
# - Programming ligatures for better code readability (==, !=, >=, etc.)
# - Mathematical symbols used in data science contexts
# - Clear distinction between similar characters (0 vs O, 1 vs l vs I)
# - Excellent rendering of data tables and aligned output
# Reference: https://github.com/ryanoasis/nerd-fonts
# font_family FiraCode Nerd Font Mono
font_size 14.0
font_family      JetBrainsMono Nerd Font Mono
bold_font        JetBrainsMono Nerd Font Mono Extra Bold
bold_italic_font JetBrainsMono Nerd Font Mono Extra Bold Italic
# VISUALIZATION AND GRAPHICS SUPPORT
# -----------------------------------------------------------------------------
# Kitty's graphics protocol enables displaying images, plots, and charts
# directly in the terminal - crucial for data science workflows:
# - Matplotlib plots via matplotlib-backend-kitty
# - Jupyter notebook cell outputs via euporie
# - Quick data visualizations without switching applications
# - Histograms and scatter plots generated by command-line tools
#
# Example integrations:
# 1. Install matplotlib-backend-kitty:
#    pip install matplotlib-backend-kitty
#    Then use: MPLBACKEND=module://matplotlib-backend-kitty python plot.py
#
# 2. Use euporie for terminal-based Jupyter notebooks:
#    pip install euporie-console
#    euporie-console notebook.ipynb
#
# 3. Display images with kitten icat:
#    kitten icat plot.png
# Reference: https://sw.kovidgoyal.net/kitty/graphics-protocol/

# KEY BINDINGS FOR DATA SCIENCE WORKFLOWS
# -----------------------------------------------------------------------------

# Quick access to scrollback for reviewing computational results
# Essential when analyzing long outputs from data processing or model training
map ctrl+shift+h show_scrollback

# Image viewing for quick plot inspection
# Example: After generating a matplotlib plot, quickly view it without
# leaving the terminal environment
map ctrl+shift+i kitten icat

# Window management for parallel data science tasks:
# - Monitor training in one pane while developing in another
# - Compare outputs from different model runs side-by-side
# - Keep documentation open while coding
map cmd+shift+d launch --location=hsplit --cwd=current

# Tab management for organizing different experiments/projects
# Example: Separate tabs for data preprocessing, model training, evaluation
map cmd+shift+] next_tab
map cmd+shift+[ previous_tab

# Zoom controls for detailed inspection of data/code
# Useful when examining detailed numerical outputs or debugging code
map cmd+plus change_font_size all +2.0
map cmd+minus change_font_size all -2.0
map cmd+0 change_font_size all 0

# Window navigation
map f8 launch --location=vsplit --cwd=current
map f10 launch --type=os-window
map f12 next_window
map f9 next_layout
map ctrl+shift+l no_op

# CLIPBOARD INTEGRATION FOR DATA SHARING
# -----------------------------------------------------------------------------
# Data scientists frequently need to copy/paste:
# - Code snippets between terminal and notebooks
# - Data samples and statistical results
# - Error messages for debugging
# - URLs to datasets and documentation
copy_on_select clipboard

# LAYOUT AND WINDOW MANAGEMENT
# -----------------------------------------------------------------------------
# Data science work benefits from multiple terminal views:
# - Monitor long-running processes while continuing development
# - Compare outputs from different model runs
# - Keep reference documentation accessible
map ctrl+shift+z toggle_layout stack
map f11 toggle_layout stack
# map ctrl+shift+r next_layout
draw_minimal_borders yes

# APPEARANCE SETTINGS
# -----------------------------------------------------------------------------
# background_opacity 0.9
window_margin_width 5 
# background_image /Users/zenn/docs/backgrounds/atlas.png
# background_image_layout scaled
# background_tint 0.85
window_border_width 2pt
inactive_border_width 1pt
# inactive_border_color #000000

# ADDITIONAL DATA SCIENCE UTILITIES
# -----------------------------------------------------------------------------
# These settings enhance the overall data science experience:

# Increase URL detection for accessing datasets, documentation, and repositories
# Data scientists frequently work with URLs to:
# - Kaggle datasets and competitions
# - GitHub repositories and documentation
# - Research papers and technical references
# - Cloud storage locations (S3, GCS buckets)
detect_urls yes

# Enable bell for long-running process notifications
# Useful for getting notified when training completes or errors occur
# Example: python train_model.py && echo -e '\a'  # Bell when training done
enable_audio_bell yes

# Optimize for working with CSV and structured data
# Better handling of wide data tables and formatted output
scrollback_fill_enlarged_window yes



# Override theme opacity settings

# OpenGL optimization settings to reduce warnings
macos_option_as_alt yes
macos_quit_when_last_window_closed yes


# BEGIN_KITTY_THEME
# 3024 Night
include current-theme.conf
# END_KITTY_THEME

# Override theme border colors (must come after theme include)
# active_border_color #00ff00

# require confirm before closing last window
confirm_os_window_close 1
```

The settings that made the largest difference for me were
`scrollback_lines 50000` (I no longer lose model training
output), `input_delay 0` (the terminal feels instant when
monitoring long-running processes), and `copy_on_select
clipboard` (selecting text copies it automatically, which saves
a surprising number of keystrokes per day).

Kitty's graphics protocol deserves a brief mention. After
installing `matplotlib-backend-kitty` (`pip install
matplotlib-backend-kitty`), you can set the environment variable
`MPLBACKEND=module://matplotlib-backend-kitty` and matplotlib
plots will render inline. For quick image inspection, `kitten
icat plot.png` displays any image directly in the terminal. I
use this constantly when reviewing generated figures.

![Neofetch system information displayed in a
terminal](media/images/ambiance2.png){.img-fluid}

*System information via neofetch -- a quick way to verify your
terminal's font rendering and colour support.*

## Zsh Shell Configuration

With Kitty configured, the next layer is the shell itself. My
`.zshrc` is organised into ten numbered sections. Each section
handles one concern, which makes it straightforward to find and
modify settings.

The full file is below.

`~/.zshrc`:

```sh

# ==========================================================================
# ZSH CONFIGURATION - REFACTORED FOR ZZCOLLAB DOCKER FILTERING
# ==========================================================================
#
# üçé MACOS-SPECIFIC CONTENT GROUPED FOR EASY IDENTIFICATION:
#
# The following sections contain macOS-specific content that will be
# automatically filtered out when creating Docker-compatible .zshrc_docker:
#
# - Section 3: macOS-specific configuration (Homebrew paths, etc.)
# - Section 8: Plugin management (brew --prefix paths)
# - Section 10: macOS-specific aliases (open, Skim, etc.)
# - Section 11: macOS-specific functions (Mathematica, etc.)
# - Section 12: macOS-specific external tools (conda paths, etc.)
#
# All sections marked with üçé will be removed or replaced in Docker containers.
#
# ==========================================================================

# ==========================================================================
# 1. ENVIRONMENT & SECURITY
# ==========================================================================

# Security: Source sensitive environment variables from separate file
[[ -f ~/.env ]] && source ~/.env

# ==========================================================================
# 2. CORE SHELL CONFIGURATION (Cross-platform)
# ==========================================================================

# Basic exports
export EDITOR="vim"
export VIMINIT='source ~/.config/vim/vimrc'
export DOCKER_BUILDKIT=1
export GITHUB_USER="rgt47"

# TeX configuration
export TEXINPUTS=".:$HOME/shr/images:$HOME/shr:"
export BIBINPUTS=".:$HOME/shr/bibfiles:$HOME/shr"

# ==========================================================================
# 3. MACOS-SPECIFIC CONFIGURATION
# ==========================================================================
# üçé ALL MACOS-SPECIFIC SETTINGS GROUPED HERE FOR EASY IDENTIFICATION

if [[ "$OSTYPE" == "darwin"* ]]; then
    # macOS-specific application configuration
    export HOMEBREW_AUTO_UPDATE_SECS="604800"

    # macOS PATH configuration (includes Homebrew paths)
    # SECURITY FIX: Removed leading "." from PATH
    export PATH="$HOME/bin:$HOME/.local/bin:/opt/homebrew/bin:/opt/homebrew/sbin:$PATH"
else
    # Linux PATH configuration
    export PATH="$HOME/bin:$HOME/.local/bin:$PATH"
fi

# ==========================================================================
# 4. CORE SHELL OPTIONS (Cross-platform)
# ==========================================================================

# Directory shortcuts
cdpath=($HOME/Dropbox $HOME/Dropbox/prj $HOME/Dropbox/sbx $HOME/Dropbox/work)

# Basic shell options
setopt auto_cd auto_pushd pushd_ignore_dups pushdminus
setopt PROMPT_SUBST

# Vi mode
bindkey -v

# Double hyphen to underscore
bindkey -s -- '--' '_'

# ==========================================================================
# 5. HISTORY MANAGEMENT (Cross-platform)
# ==========================================================================

HISTFILE="$HOME/.zsh_history"
HISTSIZE=100000
SAVEHIST=100000
setopt SHARE_HISTORY HIST_IGNORE_DUPS INC_APPEND_HISTORY HIST_VERIFY

# ==========================================================================
# 6. COMPLETION & NAVIGATION (Cross-platform)
# ==========================================================================

# PERFORMANCE: Completion system with caching (only rebuild once per day)
autoload -Uz compinit
if [[ -n ${ZDOTDIR}/.zcompdump(#qN.mh+24) ]]; then
    compinit
else
    compinit -C
fi
compdef _dirs d

# ==========================================================================
# 7. PROMPT & VCS INTEGRATION (Cross-platform)
# ==========================================================================

# Version control setup
autoload -Uz vcs_info
precmd() { vcs_info }
zstyle ':vcs_info:git:*' formats '%b '

# Custom prompt
PROMPT='%F{cyan}%m%f %F{green}%*%f %F{yellow}${${PWD:A}/$HOME/~}%f %F{red}${vcs_info_msg_0_}%f$ %(?:‚òï  :‚òî  )'

# ==========================================================================
# 8. PLUGIN MANAGEMENT (Platform-aware)
# ==========================================================================

# Load plugins based on OS
if [[ "$OSTYPE" == "linux-gnu"* ]]; then
    # Linux plugin paths
    [[ -s /home/z/.autojump/etc/profile.d/autojump.sh ]] && source /home/z/.autojump/etc/profile.d/autojump.sh
    [[ -f ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh ]] && source ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh
    [[ -f ~/.zsh/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh ]] && source ~/.zsh/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
elif [[ "$OSTYPE" == "darwin"* ]]; then
    # üçé macOS plugin paths (uses Homebrew)
    # PERFORMANCE: Cache brew --prefix to avoid slow command on every shell startup
    if [[ -z "$BREW_PREFIX" ]]; then
        export BREW_PREFIX="/opt/homebrew"
    fi
    [[ -f "$BREW_PREFIX/etc/profile.d/autojump.sh" ]] && source "$BREW_PREFIX/etc/profile.d/autojump.sh"
    [[ -f "$BREW_PREFIX/share/zsh-autosuggestions/zsh-autosuggestions.zsh" ]] && source "$BREW_PREFIX/share/zsh-autosuggestions/zsh-autosuggestions.zsh"
    [[ -f "$BREW_PREFIX/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh" ]] && source "$BREW_PREFIX/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh"
fi

# Plugin configuration
ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=red,bold,underline'

# ==========================================================================
# 9. TOOL-SPECIFIC CONFIGURATION (Cross-platform)
# ==========================================================================

# FZF configuration
if type rg &> /dev/null; then
    export FZF_DEFAULT_COMMAND='rg --files --hidden'
    export FZF_DEFAULT_OPTS='-m --height 50% --border --reverse'
fi

# ==========================================================================
# 10. ALIASES (Cross-platform)
# ==========================================================================

# Navigation aliases
alias -- -='cd -'
alias -g ...='../..'

# File listing with color support (OS-aware)
if [[ "$OSTYPE" == "darwin"* ]]; then
    # macOS (BSD ls) - check if GNU ls is installed via coreutils
    if command -v gls &> /dev/null; then
        alias ls='gls --color=auto'
        alias ll='gls -lh --color=auto'
    else
        alias ls='ls -G'
        alias ll='ls -lhG'
    fi
else
    # Linux (GNU ls)
    alias ls='ls --color=auto'
    alias ll='ls -lh --color=auto'
fi


# Directory stack navigation
alias lt='eza -lrha -sold'
alias 1='cd -1'
alias 2='cd -2'
alias 3='cd -3'
alias 4='cd -4'
alias 5='cd -5'

# Color support for common tools
alias grep='grep --color=auto'

# diff with color (OS-aware)
if [[ "$OSTYPE" == "darwin"* ]]; then
    # macOS diff doesn't support --color, check for GNU diff
    if command -v gdiff &> /dev/null; then
        alias diff='gdiff --color=auto'
    fi
else
    alias diff='diff --color=auto'
fi

# Application shortcuts
alias za='zathura'
alias hh='history'
alias R='R --quiet --no-save'
alias mm='mutt'
alias v='vim'
alias ZZ='exit'

# Config editing
alias vc='vim ~/.config/vim/vimrc'
alias vz='vim ~/Dropbox/dotfiles/zshrc'
alias sz='source ~/.zshrc'

# Safety aliases
alias tp='trash-put -v'
# alias rm='echo "This is not the command you are looking for."; false'

# ==========================================================================
# üçé MACOS-SPECIFIC ALIASES
# ==========================================================================

if [[ "$OSTYPE" == "darwin"* ]]; then
    # macOS application shortcuts
    alias sk='open -a Skim'
fi

# ==========================================================================
# 11. CUSTOM FUNCTIONS (Cross-platform)
# ==========================================================================

# Directory listing function
d() {
    if [[ -n $1 ]]; then
        dirs "$@"
    else
        dirs -v | head -n 10
    fi
}

# File finder with cd
ff() {
    local file
    file=$(rg --files "${1:-.}" 2>/dev/null | fzf --select-1 --exit-0)
    if [[ -n "$file" ]]; then
        cd "$(dirname "$file")" || return 1
    fi
}

# PDF finder with zathura (IMPROVED: converted from alias to function with error handling)
pp() {
    local pdf
    pdf=$(rg --files 2>/dev/null | rg "\.pdf$" | fzf)
    if [[ -n "$pdf" ]]; then
        zathura "$pdf" &
    fi
}

# R file finder with vim (IMPROVED: converted from alias to function with error handling)
rr() {
    local rfile
    rfile=$(rg --files 2>/dev/null | rg "\.(R|Rmd)$" | fzf)
    if [[ -n "$rfile" ]]; then
        vim "$rfile"
    fi
}

# Git workflow function: add, commit with auto-generated summary, and push
gz() {
    # Check if we're in a git repository
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        echo "Error: Not a git repository" >&2
        return 1
    fi

    # Show current status
    echo "Current git status:"
    git status --short
    echo ""

    # Add all changes
    echo "Adding files to git..."
    git add .

    # Show diff summary
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "üìù CHANGES SUMMARY"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    git diff --cached --stat
    echo ""

    # Show a preview of the actual changes (first 30 lines)
    echo "Preview of changes:"
    git diff --cached | head -30
    echo ""

    # Generate file list summary
    local summary=$(git diff --cached --name-only | head -5 | tr '\n' ', ' | sed 's/,$//')
    local file_count=$(git diff --cached --name-only | wc -l)
    if [[ $file_count -gt 5 ]]; then
        summary="$summary and $((file_count - 5)) more files"
    fi

    # Prompt for commit type with numbered options
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "Commit type:"
    echo "  1) feat       - A new feature"
    echo "  2) fix        - A bug fix"
    echo "  3) refactor   - Code refactoring"
    echo "  4) docs       - Documentation updates"
    echo "  5) test       - Adding/updating tests"
    echo "  6) chore      - Build, config, dependencies"
    echo "  7) perf       - Performance improvements"
    echo "  8) ci         - CI/CD configuration"
    echo "  9) style      - Code style (formatting, linting)"
    echo ""
    echo -n "Select commit type (1-9): "
    read type_choice

    case $type_choice in
        1) local type="feat" ;;
        2) local type="fix" ;;
        3) local type="refactor" ;;
        4) local type="docs" ;;
        5) local type="test" ;;
        6) local type="chore" ;;
        7) local type="perf" ;;
        8) local type="ci" ;;
        9) local type="style" ;;
        *) echo "Invalid choice. Using 'chore'" >&2; local type="chore" ;;
    esac

    echo -n "Scope (optional, press Enter to skip): "
    read scope
    echo -n "Description (optional, press Enter to skip): "
    read description

    # Build commit message
    local commit_msg="$type"
    [[ -n "$scope" ]] && commit_msg="$commit_msg($scope)"
    commit_msg="$commit_msg: $summary"

    if [[ -n "$description" ]]; then
        commit_msg="$commit_msg"$'\n\n'"$description"
    fi

    # Commit changes
    echo ""
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo "Committing with message:"
    echo "$commit_msg"
    echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    echo ""
    git commit -m "$commit_msg"

    if [[ $? -ne 0 ]]; then
        echo "Error: Commit failed" >&2
        return 1
    fi

    # Push to GitHub
    echo "Pushing to GitHub..."
    git push

    if [[ $? -eq 0 ]]; then
        echo "‚úÖ Successfully pushed to GitHub!"
    else
        echo "Error: Push failed" >&2
        return 1
    fi
}

# ==========================================================================
# üçé MACOS-SPECIFIC FUNCTIONS
# ==========================================================================

if [[ "$OSTYPE" == "darwin"* ]]; then
    # Mathematica script runner (macOS only) - IMPROVED: added error handling
    mma() {
        if [[ -z "$1" ]]; then
            echo "Usage: mma <script.wl>" >&2
            return 1
        fi
        if [[ ! -f "$1" ]]; then
            echo "Error: File '$1' not found" >&2
            return 1
        fi
        /Applications/Mathematica.app/Contents/MacOS/WolframKernel -script "$1"
    }
fi

# ==========================================================================
# 12. EXTERNAL TOOL INTEGRATION
# ==========================================================================

# NVM (Node Version Manager)
export NVM_DIR="$HOME/.nvm"
[[ -s "$NVM_DIR/nvm.sh" ]] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[[ -s "$NVM_DIR/bash_completion" ]] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

# XQuartz DISPLAY variable for Docker GUI apps (macOS only)
if [[ "$OSTYPE" == "darwin"* ]]; then
    if [[ -z "$DISPLAY" ]]; then
        export DISPLAY=:0
    fi
fi

# Conda initialization (platform-aware)
if [[ "$OSTYPE" == "darwin"* ]]; then
    # üçé macOS conda path
    _CONDA_ROOT="/opt/miniconda3"
elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
    # Linux conda path (adjust if different)
    _CONDA_ROOT="$HOME/miniconda3"
fi

# >>> conda initialize >>>
# !! Contents within this block are managed by 'conda init' !!
__conda_setup="$('/opt/miniconda3/bin/conda' 'shell.zsh' 'hook' 2> /dev/null)"
if [ $? -eq 0 ]; then
    eval "$__conda_setup"
else
    if [ -f "/opt/miniconda3/etc/profile.d/conda.sh" ]; then
        . "/opt/miniconda3/etc/profile.d/conda.sh"
    else
        export PATH="/opt/miniconda3/bin:$PATH"
    fi
fi
unset __conda_setup
# <<< conda initialize <<<

# alias to log claude sessions
 alias claudelog='mkdir -p ~/claude_sessions/$(date +%Y-%m-%d) && claude 2>&1 | tee ~/claude_sessions/$(date +%Y-%m-%d)/session_$(date +%H%M%S).log'

# run make from anywhere in repo
mr() {
      local dir="$PWD"
      local root=""

      # Find zzcollab project root (DESCRIPTION or .zzcollab_project)
      while [[ "$dir" != "/" ]]; do
          if [[ -f "$dir/DESCRIPTION" ]] || [[ -f "$dir/.zzcollab_project" ]]; then
              root="$dir"
              break
          fi
          dir="$(dirname "$dir")"
      done

      if [[ -z "$root" ]]; then
          echo "‚ùå Not in a ZZCOLLAB project (no DESCRIPTION or .zzcollab_project found)"
          return 1
      fi

      if [[ ! -f "$root/Makefile" ]]; then
          echo "‚ùå No Makefile in project root: $root"
          return 1
      fi

      make -C "$root" "${@:-r}"
  }
export PATH="/opt/homebrew/opt/node@22/bin:$PATH"

# ZZCOLLAB Navigation Functions (added by navigation_scripts.sh)
# These allow one-letter navigation from anywhere in your project

# Find project root (looks for DESCRIPTION file)
_zzcollab_root() {
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -f "$dir/DESCRIPTION" ]] || [[ -f "$dir/.zzcollab_project" ]]; then
            echo "$dir"
            return 0
        fi
        dir="$(dirname "$dir")"
    done
    return 1
}

# Navigation functions
a() { local root=$(_zzcollab_root); [[ -n "$root" ]] && cd "$root/analysis" || echo "Not in ZZCOLLAB project"; }
w() { local root=$(_zzcollab_root); [[ -n "$root" ]] && cd "$root/analysis/data/raw_data" || echo "Not in ZZCOLLAB project"; }
y() { local root=$(_zzcollab_root); [[ -n "$root" ]] && cd "$root/analysis/data/derived_data" || echo "Not in ZZCOLLAB project"; }
n() { local root=$(_zzcollab_root); [[ -n "$root" ]] && cd "$root/analysis" || echo "Not in ZZCOLLAB project"; }
f() { local root=$(_zzcollab_root); [[ -n "$root" ]] && cd "$root/analysis/figures" || echo "Not in ZZCOLLAB project"; }
t() { local root=$(_zzcollab_root); [[ -n "$root" ]] && cd "$root/analysis/data" || echo "Not in ZZCOLLAB project"; }
s() { local root=$(_zzcollab_root); [[ -n "$root" ]] && cd "$root/analysis/scripts" || echo "Not in ZZCOLLAB project"; }
p() { local root=$(_zzcollab_root); [[ -n "$root" ]] && cd "$root/analysis/report" || echo "Not in ZZCOLLAB project"; }
r() { local root=$(_zzcollab_root); [[ -n "$root" ]] && cd "$root/R" || echo "Not in ZZCOLLAB project"; }
0() { local root=$(_zzcollab_root); [[ -n "$root" ]] && cd "$root" || echo "Not in ZZCOLLAB project"; }
m() { local root=$(_zzcollab_root); [[ -n "$root" ]] && cd "$root/man" || echo "Not in ZZCOLLAB project"; }
e() { local root=$(_zzcollab_root); [[ -n "$root" ]] && cd "$root/tests" || echo "Not in ZZCOLLAB project"; }
o() { local root=$(_zzcollab_root); [[ -n "$root" ]] && cd "$root/docs" || echo "Not in ZZCOLLAB project"; }
c() { local root=$(_zzcollab_root); [[ -n "$root" ]] && cd "$root/archive" || echo "Not in ZZCOLLAB project"; }

# Run make targets from any subdirectory (defaults to "make r")
mr() {
    local root=$(_zzcollab_root)
    if [[ -z "$root" ]]; then
        echo "Not in ZZCOLLAB project"
        return 1
    fi
    if [[ ! -f "$root/Makefile" ]]; then
        echo "No Makefile in project root: $root"
        return 1
    fi
    make -C "$root" "${@:-r}"
}

# List navigation shortcuts
nav() {
    echo "ZZCOLLAB Navigation Shortcuts:"
    echo "  r ‚Üí project root"
    echo "  a/n ‚Üí analysis/"
    echo "  d ‚Üí analysis/data/"
    echo "  w ‚Üí analysis/data/raw_data/"
    echo "  y ‚Üí analysis/data/derived_data/"
    echo "  s ‚Üí analysis/scripts/"
    echo "  p ‚Üí analysis/report/"
    echo "  f ‚Üí analysis/figures/"
    echo "  t ‚Üí analysis/tables/"
    echo "  m ‚Üí man/"
    echo "  e ‚Üí tests/"
    echo "  o ‚Üí docs/"
    echo "  c ‚Üí archive/"
    echo ""
    echo "Make Commands (from any subdirectory):"
    echo "  mr        ‚Üí make r (start container)"
    echo "  mr test   ‚Üí make test"
    echo "  mr [target] ‚Üí make [target]"
}
# End ZZCOLLAB Navigation Functions


export PATH="/opt/homebrew/opt/postgresql@15/bin:$PATH"
export ZZEDC_TEST_BACKENDS="sqlite,duckdb,postgresql"
export ZZEDC_TEST_PG_HOST="localhost"
export ZZEDC_TEST_PG_DB="zzedc_test"
export ZZEDC_TEST_PG_USER="$USER"
export ZZEDC_TEST_PG_PASSWORD=""
```

The numbered sections are deliberate. When I need to add a new
alias, I go straight to section 8. When a plugin breaks, I look
at section 6. This organisational discipline saves time every
time I edit the file.

# Building a Workflow: Aliases and Functions in Practice

The aliases and functions in sections 8 and 9 above are the
core of my daily command-line experience. Here I want to explain
the thinking behind the ones I reach for most.

**Safety aliases.** I replaced `rm` with an error message
(`alias rm='echo "This is not the command you are looking for.";
false'`) and use `trash-put` via `tp` instead. After
accidentally deleting a dataset early in my career, I decided
that `rm` should never silently succeed. The alias forces me to
use `tp`, which moves files to the trash rather than destroying
them.

**Fuzzy finding.** The `pp` and `rr` aliases combine `ripgrep`
with `fzf` to locate PDF files and R scripts, respectively. I
type `pp`, a fuzzy search window appears listing every PDF in
the current directory tree, and I select one to open in Zathura.
The `ff` function does the same but changes directory to
wherever the selected file lives.

**Directory navigation.** The `cdpath` variable is one of the
most underrated Zsh features I have encountered. By setting
`cdpath=($HOME/Dropbox $HOME/Dropbox/prj)`, I can type
`cd myproject` from anywhere and Zsh will find it inside
`~/Dropbox/prj/myproject` without a full path. Combined with
`auto_cd` (which lets me type a directory name without `cd`)
and `auto_pushd` (which maintains a directory stack accessible
via `d`), navigation becomes almost frictionless.

**The prompt.** My prompt shows the current time (green), the
working directory (yellow), the git branch (red), and a status
indicator: a coffee cup if the last command succeeded, a rain
cloud if it failed. The git branch display alone has saved me
from committing to the wrong branch dozens of times.

# Checking Our Work: Verifying the Configuration

After copying these configuration files into place, it is worth
verifying that everything loaded correctly.

**Check Kitty settings:**

```bash
kitty --version
kitty +kitten themes --list
```

The first command confirms Kitty is installed. The second lists
available themes, which verifies that the Kitty kitten system is
working.

**Check Zsh and plugins:**

```bash
zsh --version
echo $SHELL
which autojump 2>/dev/null && echo "autojump: loaded" \
  || echo "autojump: not found"
type fzf 2>/dev/null && echo "fzf: loaded" \
  || echo "fzf: not found"
```

**Verify the prompt shows git information:**

```bash
cd /path/to/any/git/repo
# The prompt should display the branch name in red
```

**Test safety aliases:**

```bash
rm test.txt
# Expected output: "This is not the command you are
#   looking for."
```

If any plugin fails to load, the `[[ -f ... ]] && source ...`
guards in section 6 mean Zsh will continue without error. This
is deliberate: I would rather have a working shell with a
missing plugin than a broken shell.

## Things to Watch Out For

1. **Duplicate key bindings.** I initially defined the same
   Kitty keybinding in both the basic and data-science sections
   of my config. Kitty uses the last definition, so the earlier
   one was silently ignored. Merge your config into one file to
   avoid this.

2. **Plugin startup cost.** Loading `zsh-syntax-highlighting`,
   `zsh-autosuggestions`, and `autojump` adds roughly 100-200ms
   to shell startup. If you notice lag when opening new
   terminals, profile with `zsh -xv` and consider lazy-loading.

3. **`cdpath` collisions.** If two directories in your `cdpath`
   contain subdirectories with the same name, Zsh picks the
   first match. I once spent twenty minutes wondering why `cd
   data` took me to the wrong project.

4. **Conda and PATH pollution.** The conda initialisation block
   modifies `$PATH` every time a shell starts. If you open many
   terminal tabs, check that `$PATH` has not accumulated
   duplicate entries with `echo $PATH | tr ':' '\n' | sort |
   uniq -d`.

5. **Font fallback on Linux.** FiraCode Nerd Font Mono must be
   installed system-wide on Linux for Kitty to find it. If
   prompt icons render as boxes, run `fc-list | grep -i fira` to
   verify the font is visible to fontconfig.

![A lofi aesthetic workspace with warm lighting and a laptop
screen](media/images/ambiance3.jpg){.img-fluid}

*The calm focus of a well-tuned workspace -- what a
thoughtfully configured terminal makes possible.*

## Lessons Learnt

### Conceptual Understanding

- A terminal configuration is a layered system: the emulator
  (Kitty) handles rendering and input; the shell (Zsh) handles
  commands, history, and scripting. Configuring them separately
  keeps each layer clean.
- Scrollback and performance settings are not cosmetic. A
  50,000-line buffer and zero input delay make a tangible
  difference when reviewing long model outputs.
- Directory navigation is a solved problem in Zsh. Between
  `cdpath`, `auto_pushd`, and `autojump`, there is no reason to
  type full paths.
- The prompt is an information display, not decoration. Showing
  git branch and exit status prevents real errors.

### Technical Skills

- I learnt to use `vcs_info` for lightweight git integration in
  the prompt, avoiding the overhead of Oh My Zsh.
- Cross-platform plugin loading via `$OSTYPE` checks lets me
  share one `.zshrc` between macOS and Linux.
- Combining `ripgrep` with `fzf` for file finding (the `pp`,
  `rr`, and `ff` functions) replaced several GUI tools I used
  to depend on.
- Kitty's remote control API (`kitty @`) opens possibilities
  for scripting terminal layouts, which I use when setting up
  experiment monitoring.

### Gotchas and Pitfalls

- Overriding `rm` with a safety alias means scripts that call
  `rm` will also fail. Use `command rm` or `/bin/rm` in scripts
  when you genuinely need to delete.
- `setopt SHARE_HISTORY` shares history across all terminal
  sessions in real time, which can be disorienting if you are
  not expecting it.
- The `_load_plugin` helper function defined in section 6 is
  currently unused because I found inline conditionals more
  readable for three plugins. It would become useful with more
  plugins.
- Kitty's `background_image` setting accepts an absolute path.
  If the image file moves, Kitty starts with a black background
  and no error message.

## Limitations

- This configuration is tested only on macOS (Sonoma) and
  Ubuntu 22.04. Other distributions may require different
  plugin paths or package names.
- The `.zshrc` includes hardcoded paths (e.g.,
  `/opt/miniconda3`, `/home/z/.autojump`) that will not work
  on other machines without editing.
- The Kitty configuration references a background image at an
  absolute path that is specific to my machine.
- Plugin loading adds startup latency. For remote servers where
  shell startup time matters (e.g., inside Docker containers),
  a stripped-down `.zshrc` would be more appropriate.
- The `cdpath` approach does not scale well to deeply nested
  project structures with many similarly-named subdirectories.
- No automated testing or linting is applied to these
  configuration files. A typo in `.zshrc` is only caught when
  the shell starts.

## Opportunities for Improvement

1. Store the configuration in a dotfiles repository with a
   symlink-based installer (see my companion post on GitHub
   dotfiles).
2. Replace hardcoded paths with environment variables or
   auto-detection logic to improve portability.
3. Add lazy-loading for plugins to reduce shell startup time
   below 50ms.
4. Integrate with a tiling window manager (Rectangle on macOS,
   i3/Sway on Linux) to automate window positioning alongside
   terminal splits.
5. Add Karabiner-Elements (macOS) or custom keybindings (Linux)
   for a global hotkey to summon Kitty instantly.
6. Write a shell function that profiles `.zshrc` startup time
   and identifies slow sections automatically.

# Wrapping Up

Configuring a terminal is not glamorous work, but it compounds.
Every alias that saves two seconds, every prompt element that
prevents a mistake, and every navigation shortcut that avoids a
full path -- they add up across thousands of commands per week.

What I found most valuable was the organisational discipline:
ten numbered sections in `.zshrc`, one merged `kitty.conf`, and
a clear separation between the terminal emulator and the shell.
When something breaks, I know exactly where to look. When I want
to add something new, I know exactly where to put it.

If you are starting from a default terminal setup, I would
suggest focusing on three things first: a Nerd Font for icon
support, `cdpath` for directory navigation, and `fzf` for fuzzy
file finding. Those three changes alone made the biggest
difference in my daily workflow.

**Main takeaways:**

- A 50,000-line scrollback buffer prevents losing model training
  output.
- `cdpath` and `auto_pushd` eliminate most `cd ../../..` chains.
- Replacing `rm` with a trash alias prevents accidental data
  loss.
- Cross-platform plugin loading via `$OSTYPE` keeps one `.zshrc`
  working on both macOS and Linux.

# See Also

**Related posts:**

- [Creating a GitHub Dotfiles Repository for Configuration
  Management](/posts/24-setupdotfilesongithub/) -- how to
  version-control the files described in this post
- [Setting Up Neovim for Data Science
  Development](/posts/12-configneovim/) -- the editor layer
  that sits on top of this terminal configuration

**Key resources:**

- [Kitty Terminal Documentation](https://sw.kovidgoyal.net/kitty/)
  -- the official reference for all configuration options
- [Zsh Documentation](https://zsh.sourceforge.io/Doc/) --
  official manual covering options, completion, and scripting
- [FZF](https://github.com/junegunn/fzf) -- the fuzzy finder
  used throughout this configuration
- [Ripgrep](https://github.com/BurntSushi/ripgrep) -- the
  search tool that powers `fzf` file finding here
- [Configuring Zsh Without Dependencies](https://thevaluable.dev/zsh-install-configure-mouseless/)
  -- an excellent guide to building a Zsh config from scratch

# Reproducibility

**Environment requirements:**

- macOS 10.15+ or Linux (Ubuntu 18.04+, Fedora 30+)
- Zsh 5.0+, Git, Homebrew (macOS)
- FiraCode Nerd Font Mono
- Optional: `fzf`, `ripgrep`, `eza`, `autojump`, `trash-cli`

**Configuration file locations:**

- Kitty: `~/.config/kitty/kitty.conf`
- Zsh: `~/.zshrc`
- Environment secrets: `~/.env` (not version-controlled)

**Version checks:**

```bash
zsh --version
kitty --version
brew --version    # macOS only
fzf --version
rg --version
```

# Let's Connect

- **GitHub**: [rgt47](https://github.com/rgt47)
- **Twitter/X**: [@rgt47](https://twitter.com/rgt47)
- **LinkedIn**: [Ronald Glenn Thomas](https://linkedin.com/in/rgthomaslab)
- **Email**: [Contact through website](https://rgtlab.org/contact)

I would enjoy hearing from you if you:

- Spot an error or have a correction
- Have a better approach to any of these configurations
- Want to share your own terminal setup
- Have questions about adapting this for a specific workflow
- Just want to connect and talk about command-line tools
