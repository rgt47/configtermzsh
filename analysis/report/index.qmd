---
title: "Configure the Command Line for Data Science Development"
subtitle: "Setting up Kitty terminal, Zsh shell, and
  productivity tools for everyday data science work"
author: "Ronald G. Thomas"
date: "2026-02-16"
categories: [terminal, zsh, macos, configuration, git, neovim]
description: "A systematic approach to configuring command-line
  tools for data science workflows, covering terminal emulation,
  shell configuration, version control, and readline settings."
image: "media/images/kitty-icon.png"
document-type: "blog"
draft: false
execute:
  echo: true
  warning: false
  message: false
format:
  html:
    code-fold: false
    code-tools: false
---

![The Kitty terminal emulator logo, a stylized cat face in
neon colors](media/images/kitty-icon.png){.img-fluid width=50%
fig-align="center"}

*The Kitty terminal emulator: a GPU-accelerated terminal built
for power users. Icon by [DinkDonk](https://github.com/DinkDonk/kitty-icon).*

# Introduction


The configuration presented here is opinionated. It reflects a
data science workflow centred on R, Python, Docker, Git, and
fuzzy finders. Individual workflows will differ, but the
structural decisions (how to organise configuration files, which
settings provide measurable benefit, and how to maintain
portability) should transfer to other contexts.

This post covers four configuration files that work together:

- **kitty.conf**: terminal emulator (rendering, keybindings,
  appearance)
- **.zshrc**: shell (environment, history, aliases, functions)
- **.gitconfig**: version control (identity, authentication,
  behaviour)
- **.inputrc**: readline (vi mode consistency across CLI tools)

## Motivations

The following pain points motivated this configuration:

- Excessive keystrokes navigating between project directories,
  with `cd ../../..` chains becoming unwieldy.
- Default terminal scrollback buffers of 2,000 lines, which
  causes model training output to be lost before review.
- Absence of visual indicators for the current git branch,
  leading to commits on the wrong branch.
- Plugin installation without a clear cross-platform loading
  strategy that functions on both macOS and Linux.
- Aliases accumulating in scattered locations rather than in a
  single, well-organised configuration file.
- Lack of inline image support for viewing matplotlib plots
  directly in the terminal.

## Objectives

1. Install and configure Kitty terminal with settings for fonts,
   colours, performance, and data-science workflows.
2. Set up Zsh with a modular `.zshrc` that handles environment
   variables, history, completion, prompts, plugins, aliases, and
   custom functions in clearly separated sections.
3. Configure Git with GitHub CLI authentication, sensible
   defaults, and useful aliases.
4. Set up Readline for consistent vi-mode keybindings across all
   CLI tools (R, Python, database clients).
5. Implement productivity shortcuts (directory jumping,
   fzf-powered file finding, and safety aliases) that reduce
   repetitive typing.
6. Configure cross-platform loading so the same dotfiles work on
   macOS and Linux without modification.

Corrections and alternative approaches are welcome.

![An organized desk workspace with warm lighting](media/images/organized.jpg){.img-fluid}

*A well-organized workspace reflects a well-organized configuration:
the goal of this entire setup.*

# Prerequisites and Setup

This post assumes you have administrative privileges on a macOS
or Linux machine and are comfortable running commands in a
terminal. You will need:

- **macOS**: Homebrew (`brew`) installed
- **Linux**: A system package manager (apt, dnf, or pacman)
- **Both**: Git and Zsh 5.0+

**macOS installation:**

```bash
brew install kitty
```

**Linux installation:**

```bash
# Ubuntu/Debian
sudo apt-get install kitty

# Fedora/RHEL
sudo dnf install kitty

# Arch Linux
sudo pacman -S kitty
```

Kitty stores its configuration in `~/.config/kitty/kitty.conf`.
Zsh reads `~/.zshrc` at startup. Both files are plain text and
can be version-controlled in a dotfiles repository.

# What is Kitty?

Kitty is a GPU-accelerated terminal emulator written in C and
Python. Unlike traditional terminals, it offloads rendering to
the GPU, which makes scrolling through large outputs noticeably
smoother. Its main appeal for data science work is the built-in
graphics protocol: you can display images, plots, and charts
directly in the terminal window using `kitten icat` or
backend libraries like `matplotlib-backend-kitty`.

Think of Kitty as a terminal that understands pictures. Where a
standard terminal can only show text, Kitty can render a
matplotlib scatter plot inline, right below the command that
generated it.

# Getting Started: Kitty Terminal Configuration

The configuration below presents a complete `kitty.conf`, built
up iteratively. Rather than presenting it as a single block, this
section walks through each portion and explains the reasoning
behind the settings.

`~/.config/kitty/kitty.conf`:

## Cursor and Basic Behaviour

```sh
cursor_shape block
cursor_blink_interval 0
```

A solid block cursor with no blinking reduces visual noise when
reading code. The blinking cursor is distracting during extended
work sessions. Some users prefer `cursor_shape beam` for a thinner
insertion point, but the block cursor is easier to locate after
shifting attention away from the screen.

## Scrollback Buffer

```sh
scrollback_lines 50000
scrollback_pager less --chop-long-lines --RAW-CONTROL-CHARS +INPUT_LINE_NUMBER
scrollback_fill_enlarged_window yes
```

The default scrollback of 2,000 lines is inadequate for data
science work. Model training runs, database query results, and
error traces routinely exceed that limit. Increasing this to
50,000 lines covers most workflows without consuming excessive
memory.

The `scrollback_pager` setting opens the entire terminal history
in `less` by pressing `Ctrl+Shift+H`. This proves invaluable when
searching through long training logs for specific metrics or
error messages. The `+INPUT_LINE_NUMBER` flag positions the pager
at the current scroll position rather than the top.

## Performance Tuning

```sh
repaint_delay 2
input_delay 0
sync_to_monitor yes
```

These settings reduce latency when the terminal is updating
rapidly. With `input_delay 0`, keystrokes register immediately
even when a long-running process is flooding the screen with
output. The `repaint_delay 2` (milliseconds) keeps the display
smooth when streaming data through command-line tools.

The setting `sync_to_monitor yes` avoids screen tearing. If lag
appears during intensive output, setting it to `no` can help.
The trade-off is occasional visual artifacts during rapid
scrolling.

## Window Layout and Padding

```sh
initial_window_width  1024
initial_window_height 768
window_padding_width 4
window_margin_width 5
window_border_width 2pt
inactive_border_width 1pt
draw_minimal_borders yes
```

The initial window size provides a reasonable starting point
that can be resized as needed. The padding and margin settings
add breathing room around the terminal content, which reduces
eye strain during long sessions. Minimal borders keep the
interface clean when using split panes.

## Tab Bar Appearance

```sh
tab_bar_edge bottom
tab_bar_style powerline
tab_powerline_style slanted
```

Placing the tab bar at the bottom positions it in the natural
resting area of the eyes when typing. The powerline style with
slanted separators provides clear visual distinction between tabs
without being distracting.

## Basic Key Bindings

```sh
map cmd+d launch --location=vsplit --cwd=current
map cmd+w close_window
map cmd+shift+w close_tab
map cmd+t new_tab
map cmd+shift+] next_tab
map cmd+shift+[ previous_tab

map cmd+1 goto_tab 1
map cmd+2 goto_tab 2
map cmd+3 goto_tab 3
map cmd+4 goto_tab 4
map cmd+5 goto_tab 5
```

These bindings mirror standard macOS application behaviour.
`Cmd+D` splits the current pane vertically (the `--cwd=current`
flag ensures the new pane starts in the same directory). The tab
shortcuts allow jumping directly to a specific tab without
cycling through them.

## Zoom and Font Size

```sh
map cmd+plus change_font_size all +2.0
map cmd+minus change_font_size all -2.0
map cmd+0 change_font_size all 0
map ctrl+shift+z toggle_layout stack
map f11 toggle_layout stack
```

Quick font resizing is essential when sharing screens or reading
dense output. The `toggle_layout stack` binding temporarily
maximises the current pane, which is useful for focusing on one
window without closing others.

## Clipboard Integration

```sh
map cmd+c copy_to_clipboard
map cmd+v paste_from_clipboard
copy_on_select clipboard
```

The `copy_on_select clipboard` setting is a significant
time-saver. Selecting text with the mouse automatically copies
it to the clipboard, eliminating the extra `Cmd+C` keystroke.
This proves useful when copying error messages or code snippets.

## Remote Control and Shell Integration

```sh
allow_remote_control yes
listen_on unix:/tmp/kitty
```

Remote control enables scripting Kitty from the command line. For
example, window titles can be set programmatically to track
different experiments:

```bash
kitty @ set-window-title "Model-XGBoost-Experiment-1"
```

This is particularly useful when running multiple training jobs
and needing to identify which terminal corresponds to which
experiment.

## Font Configuration

```sh
font_size 14.0
font_family      JetBrainsMono Nerd Font Mono
bold_font        JetBrainsMono Nerd Font Mono Extra Bold
bold_italic_font JetBrainsMono Nerd Font Mono Extra Bold Italic
```

JetBrains Mono renders clearly at small sizes and includes
programming ligatures that make operators like `!=` and `>=` more
readable. The Nerd Font variant adds icons used by many
command-line tools and prompt themes. At 14pt, the font is
comfortable for extended reading without wasting screen space.

## Data Science Key Bindings

```sh
map ctrl+shift+h show_scrollback
map ctrl+shift+i kitten icat
map cmd+shift+d launch --location=hsplit --cwd=current
map f8 launch --location=vsplit --cwd=current
map f10 launch --type=os-window
map f12 next_window
map f9 next_layout
map ctrl+shift+l no_op
```

These bindings support data science workflows specifically.
`Ctrl+Shift+H` opens the scrollback in the pager for searching
through training logs. `Ctrl+Shift+I` launches `kitten icat` for
viewing images directly in the terminal (useful for quick plot
inspection). The split bindings (`Cmd+Shift+D` for horizontal,
`F8` for vertical) enable monitoring a training run in one pane
while continuing to work in another.

## URL Detection and Notifications

```sh
detect_urls yes
enable_audio_bell yes
```

URL detection makes it easy to open links to documentation,
datasets, and GitHub repositories by clicking on them. The audio
bell provides a notification when long-running processes
complete. Appending `&& echo -e '\a'` to training commands
provides an audible signal upon completion.

## macOS-Specific Settings

```sh
macos_option_as_alt yes
macos_quit_when_last_window_closed yes
confirm_os_window_close 1
```

On macOS, `macos_option_as_alt` allows using Option as the Alt
key, which is necessary for many terminal applications that
expect Alt+key combinations. The quit and confirm settings
prevent accidental closure of important terminal sessions.

## Theme

```sh
# BEGIN_KITTY_THEME
# 3024 Night
include current-theme.conf
# END_KITTY_THEME
```

This example uses a dark theme (3024 Night) stored in a separate
file. Kitty manages themes through its theme system, which makes
switching themes easy without editing the main configuration. Run
`kitty +kitten themes` to browse and install themes.

---

The settings that make the largest difference are
`scrollback_lines 50000` (model training output is no longer
lost), `input_delay 0` (the terminal feels instant when
monitoring long-running processes), and `copy_on_select
clipboard` (selecting text copies it automatically, which saves
a surprising number of keystrokes per day).

Kitty's graphics protocol deserves a brief mention. After
installing `matplotlib-backend-kitty` (`pip install
matplotlib-backend-kitty`), the environment variable
`MPLBACKEND=module://matplotlib-backend-kitty` causes matplotlib
plots to render inline. For quick image inspection, `kitten
icat plot.png` displays any image directly in the terminal. This
proves useful when reviewing generated figures.

![Neofetch system information displayed in a
terminal](media/images/ambiance2.png){.img-fluid}

*System information via neofetch: a quick way to verify
terminal font rendering and colour support.*

## Zsh Shell Configuration

With Kitty configured, the next layer is the shell itself. This
`.zshrc` is organised into twelve numbered sections, each
handling one concern. The following subsections walk through each
portion and explain the reasoning.

A key design principle: every optional dependency is wrapped in
a conditional check. If a tool like `autojump` or `ripgrep` is
not installed, the configuration degrades gracefully rather than
throwing errors.

`~/.zshrc`:

### Environment and Security

```sh
[[ -f ~/.env ]] && source ~/.env
```

Sensitive information (API keys, tokens, database credentials)
lives in a separate `~/.env` file that is not version-controlled.
This single line sources it if it exists and does nothing if it
does not. Secrets should never be committed to a dotfiles
repository.

### Core Shell Configuration

```sh
export EDITOR="vim"
export VIMINIT='source ~/.config/vim/vimrc'
export DOCKER_BUILDKIT=1
export GITHUB_USER="mygit"

export TEXINPUTS=".:$HOME/shr/images:$HOME/shr:"
export BIBINPUTS=".:$HOME/shr/bibfiles:$HOME/shr"
```

These exports set the default editor and configure paths for
LaTeX. The `DOCKER_BUILDKIT=1` enables Docker's improved build
system, which provides better caching and parallel builds. The
`GITHUB_USER` variable is used by various scripts that interact
with GitHub.

### Platform-Specific PATH Configuration

```sh
if [[ "$OSTYPE" == "darwin"* ]]; then
    export HOMEBREW_AUTO_UPDATE_SECS="604800"
    export PATH="$HOME/bin:$HOME/.local/bin:/opt/homebrew/bin:/opt/homebrew/sbin:$PATH"
else
    export PATH="$HOME/bin:$HOME/.local/bin:$PATH"
fi
```

This is the first example of cross-platform logic. On macOS, the
configuration includes Homebrew's paths and throttles automatic
updates to once per week (604800 seconds). On Linux, the Homebrew
paths are omitted since they do not exist. The `$OSTYPE` variable
is set by Zsh and reliably distinguishes between operating
systems.

Note the security consideration: a leading `.` should not appear
in PATH. Having `.` in PATH means the shell will execute programs
in the current directory, which is a security risk when changing
into untrusted directories.

### Core Shell Options

```sh
cdpath=($HOME/Dropbox $HOME/Dropbox/prj $HOME/Dropbox/sbx $HOME/Dropbox/work)

setopt auto_cd auto_pushd pushd_ignore_dups pushdminus
setopt PROMPT_SUBST

bindkey -v
bindkey -s -- '--' '_'
```

The `cdpath` variable is one of Zsh's most underrated features.
With this setting, typing `cd myproject` from anywhere causes
Zsh to search `~/Dropbox/prj/myproject` automatically. Combined
with `auto_cd` (which permits omitting `cd` entirely and just
typing a directory name), navigation becomes remarkably fast.

The `auto_pushd` option maintains a directory stack that can be
navigated with numbered aliases (`1`, `2`, `3`, etc.) defined
later. `PROMPT_SUBST` enables variable expansion in the prompt.

The vi mode (`bindkey -v`) is configured for users whose muscle
memory expects hjkl navigation and Escape to exit insert mode.
The `--` to `_` binding is a small convenience: typing two
hyphens produces an underscore, which is faster for snake_case
identifiers.

### History Management

```sh
HISTFILE="$HOME/.zsh_history"
HISTSIZE=100000
SAVEHIST=100000
setopt SHARE_HISTORY HIST_IGNORE_DUPS INC_APPEND_HISTORY HIST_VERIFY
```

Keeping 100,000 lines of history is reasonable because disk space
is cheap and recalling commands from weeks ago is frequently
necessary. The options work together:

- `SHARE_HISTORY` syncs history across all terminal sessions in
  real time (some users find this disorienting)
- `HIST_IGNORE_DUPS` avoids cluttering history with repeated
  commands
- `INC_APPEND_HISTORY` writes each command immediately rather
  than at session end
- `HIST_VERIFY` shows the expanded command before executing when
  using history substitution (e.g., `!!`), providing a chance to
  review before running

### Completion System

```sh
autoload -Uz compinit
if [[ -n ${ZDOTDIR}/.zcompdump(#qN.mh+24) ]]; then
    compinit
else
    compinit -C
fi
compdef _dirs d
```

The completion system is one of Zsh's strengths, but initialising
it on every shell startup adds latency. This code caches the
completion dump file and only regenerates it if it is more than
24 hours old. The result is noticeably faster shell startup.

The `compdef _dirs d` line tells Zsh to use directory completion
for the custom `d` function defined later.

### Prompt and Git Integration

```sh
autoload -Uz vcs_info
precmd() { vcs_info }
zstyle ':vcs_info:git:*' formats '%b '

PROMPT='%F{cyan}%m%f %F{green}%*%f %F{yellow}${${PWD:A}/$HOME/~}%f %F{red}${vcs_info_msg_0_}%f$ %(?:☕  :☔  )'
```

This prompt displays:

- Hostname in cyan (useful when SSHing between machines)
- Current time in green
- Working directory in yellow (with `~` substituted for `$HOME`)
- Git branch in red (via `vcs_info`)
- A coffee cup if the last command succeeded, a rain cloud if it
  failed

The `vcs_info` approach is lightweight compared to Oh My Zsh's
git plugin. It runs in the `precmd` hook before each prompt and
extracts just the branch name. This helps prevent committing to
the wrong branch.

### Plugin Management

```sh
if [[ "$OSTYPE" == "linux-gnu"* ]]; then
    [[ -s /home/z/.autojump/etc/profile.d/autojump.sh ]] && source /home/z/.autojump/etc/profile.d/autojump.sh
    [[ -f ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh ]] && source ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh
    [[ -f ~/.zsh/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh ]] && source ~/.zsh/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
elif [[ "$OSTYPE" == "darwin"* ]]; then
    if [[ -z "$BREW_PREFIX" ]]; then
        export BREW_PREFIX="/opt/homebrew"
    fi
    [[ -f "$BREW_PREFIX/etc/profile.d/autojump.sh" ]] && source "$BREW_PREFIX/etc/profile.d/autojump.sh"
    [[ -f "$BREW_PREFIX/share/zsh-autosuggestions/zsh-autosuggestions.zsh" ]] && source "$BREW_PREFIX/share/zsh-autosuggestions/zsh-autosuggestions.zsh"
    [[ -f "$BREW_PREFIX/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh" ]] && source "$BREW_PREFIX/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh"
fi

ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=red,bold,underline'
```

Three plugins are employed here, each addressing a specific
friction point in command-line work:

**autojump** maintains a database of directories you visit,
weighted by frequency. After using it for a few days, you can
type `j proj` to jump to `~/Dropbox/prj/myproject` without
typing the full path. It learns from your behaviour: the more
often you visit a directory, the higher it ranks in fuzzy
matching. Install with `brew install autojump` (macOS) or
`apt install autojump` (Ubuntu). The only downside is the
initial learning period; it takes a week or two of normal usage
before the database becomes useful.

**zsh-autosuggestions** displays ghost text showing a prediction
of what the user might type next, based on command history. As
typing begins with `git`, it might suggest `git status` in grey
text. Pressing the right arrow key accepts the entire suggestion,
or `Ctrl+E` accepts just to the end of the current word. This
plugin dramatically reduces typing for repetitive commands.
Install with `brew install zsh-autosuggestions` (macOS) or clone
from GitHub on Linux. The `ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE`
setting controls how suggestions appear; red bold underline makes
them visually distinct from actual typing.

**zsh-syntax-highlighting** provides real-time syntax
highlighting as you type. Valid commands appear in green,
unknown commands in red, quoted strings in yellow, and paths
that exist are underlined. This catches typos before you press
Enter: if `git comit` appears in red, you know immediately that
it is not a valid command. Install with
`brew install zsh-syntax-highlighting` (macOS) or clone from
GitHub on Linux. Note that this plugin must be sourced last in
your `.zshrc` to work correctly with other plugins.

The conditional loading pattern (`[[ -f ... ]] && source ...`)
means Zsh will not error if a plugin is missing. This is
essential for sharing the same `.zshrc` across machines where
not all plugins are installed. If autojump is not present, that
line does nothing and the shell continues to load.

On macOS, caching `BREW_PREFIX` avoids calling `brew --prefix`
on every shell startup. Without caching, `brew --prefix` adds
roughly 200-400ms to shell startup time, which is noticeable
when opening new terminal tabs. Hardcoding `/opt/homebrew`
(the default on Apple Silicon Macs) eliminates this delay.

![A calm workspace with soft lighting](media/images/softmood.png){.img-fluid}

*The rhythm of configuration: small decisions compound into a
seamless workflow.*

### FZF Configuration

```sh
if type rg &> /dev/null; then
    export FZF_DEFAULT_COMMAND='rg --files --hidden'
    export FZF_DEFAULT_OPTS='-m --height 50% --border --reverse'
fi
```

This configures `fzf` (fuzzy finder) to use `ripgrep` as its file
source, but only if `ripgrep` is installed. The options enable
multi-select (`-m`), use half the terminal height, add a border,
and reverse the list so matches appear at the bottom near the
prompt.

### Navigation Aliases

```sh
alias -- -='cd -'
alias -g ...='../..'

alias 1='cd -1'
alias 2='cd -2'
alias 3='cd -3'
alias 4='cd -4'
alias 5='cd -5'
```

The `-` alias allows typing just `-` to return to the previous
directory. The `...` global alias expands to `../..` anywhere in
a command. The numbered aliases navigate the directory stack
maintained by `auto_pushd`.

### File Listing with Colour

```sh
if [[ "$OSTYPE" == "darwin"* ]]; then
    if command -v gls &> /dev/null; then
        alias ls='gls --color=auto'
        alias ll='gls -lh --color=auto'
    else
        alias ls='ls -G'
        alias ll='ls -lhG'
    fi
else
    alias ls='ls --color=auto'
    alias ll='ls -lh --color=auto'
fi

alias lt='eza -lrha -sold'
alias grep='grep --color=auto'
```

macOS ships with BSD `ls`, which uses `-G` for colour. Linux
uses GNU `ls`, which uses `--color=auto`. If GNU coreutils is
installed on macOS (via `brew install coreutils`), `gls` provides
consistency. The `lt` alias uses `eza` (a modern `ls`
replacement) to list files sorted by modification time.

### Application Shortcuts

```sh
alias za='zathura'
alias hh='history'
alias R='R --quiet --no-save'
alias mm='mutt'
alias v='vim'
alias ZZ='exit'

alias vc='vim ~/.config/vim/vimrc'
alias vz='vim ~/Dropbox/dotfiles/zshrc'
alias sz='source ~/.zshrc'
```

These are simple shortcuts for frequently used programs. The
`R` alias starts R without the startup message and without
prompting to save the workspace on exit. `ZZ` mirrors vim's exit
command. The config editing aliases (`vc`, `vz`, `sz`) make
editing and reloading configuration files efficient.

### Safety Aliases

```sh
alias tp='trash-put -v'
# alias rm='echo "This is not the command you are looking for."; false'
```

After accidentally deleting important data, many users adopt
`trash-put` from the `trash-cli` package. The `tp` alias moves
files to the trash rather than deleting them permanently. The
`rm` override is kept commented out because it breaks scripts
that legitimately need to delete files, but uncommenting it
provides an extra safety net during interactive use.

![UCSD Geisel Library at dusk](media/images/ucsd-geisel-library.jpg){.img-fluid}

*Configuration as architecture, with each layer built
deliberately upon the one below.*

### Fuzzy Finding Functions

```sh
d() {
    if [[ -n $1 ]]; then
        dirs "$@"
    else
        dirs -v | head -n 10
    fi
}

ff() {
    local file
    file=$(rg --files "${1:-.}" 2>/dev/null | fzf --select-1 --exit-0)
    if [[ -n "$file" ]]; then
        cd "$(dirname "$file")" || return 1
    fi
}

pp() {
    local pdf
    pdf=$(rg --files 2>/dev/null | rg "\.pdf$" | fzf)
    if [[ -n "$pdf" ]]; then
        zathura "$pdf" &
    fi
}

rr() {
    local rfile
    rfile=$(rg --files 2>/dev/null | rg "\.(R|Rmd)$" | fzf)
    if [[ -n "$rfile" ]]; then
        vim "$rfile"
    fi
}
```

These functions combine `ripgrep` with `fzf` for rapid file
navigation:

- `d` shows the directory stack (up to 10 entries)
- `ff` finds any file and `cd`s to its directory
- `pp` finds PDF files and opens them in Zathura
- `rr` finds R or Rmd files and opens them in vim

The pattern is consistent: use `ripgrep` to list files, pipe to
`fzf` for selection, then take action on the result. These
functions can largely replace graphical file managers for many
workflows.

### Git Workflow Function

```sh
gz() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        echo "Error: Not a git repository" >&2
        return 1
    fi

    echo "Current git status:"
    git status --short
    echo ""

    git add .

    echo "═══════════════════════════════════════════════════════════"
    git diff --cached --stat
    echo ""
    git diff --cached | head -30
    echo ""

    local summary=$(git diff --cached --name-only | head -5 | tr '\n' ', ' | sed 's/,$//')
    local file_count=$(git diff --cached --name-only | wc -l)
    if [[ $file_count -gt 5 ]]; then
        summary="$summary and $((file_count - 5)) more files"
    fi

    echo "Commit type:"
    echo "  1) feat   2) fix   3) refactor   4) docs   5) test"
    echo "  6) chore  7) perf  8) ci         9) style"
    echo -n "Select (1-9): "
    read type_choice

    case $type_choice in
        1) local type="feat" ;;
        2) local type="fix" ;;
        3) local type="refactor" ;;
        4) local type="docs" ;;
        5) local type="test" ;;
        6) local type="chore" ;;
        7) local type="perf" ;;
        8) local type="ci" ;;
        9) local type="style" ;;
        *) local type="chore" ;;
    esac

    echo -n "Scope (optional): "
    read scope
    echo -n "Description (optional): "
    read description

    local commit_msg="$type"
    [[ -n "$scope" ]] && commit_msg="$commit_msg($scope)"
    commit_msg="$commit_msg: $summary"
    [[ -n "$description" ]] && commit_msg="$commit_msg"$'\n\n'"$description"

    git commit -m "$commit_msg"
    [[ $? -ne 0 ]] && return 1

    git push
}
```

The `gz` function implements a guided git workflow: stage all
changes, show a summary, prompt for a conventional commit type
and optional scope, generate a commit message, and push. This
enforces consistent commit message formatting without requiring
the user to remember the exact syntax each time.

### External Tool Integration

```sh
export NVM_DIR="$HOME/.nvm"
[[ -s "$NVM_DIR/nvm.sh" ]] && \. "$NVM_DIR/nvm.sh"
[[ -s "$NVM_DIR/bash_completion" ]] && \. "$NVM_DIR/bash_completion"

if [[ "$OSTYPE" == "darwin"* ]]; then
    if [[ -z "$DISPLAY" ]]; then
        export DISPLAY=:0
    fi
fi
```

NVM (Node Version Manager) is loaded conditionally. The
`DISPLAY` variable setup is for running GUI applications inside
Docker containers on macOS via XQuartz.

### Conda Initialization

```sh
if [[ "$OSTYPE" == "darwin"* ]]; then
    _CONDA_ROOT="/opt/miniconda3"
elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
    _CONDA_ROOT="$HOME/miniconda3"
fi

__conda_setup="$('/opt/miniconda3/bin/conda' 'shell.zsh' 'hook' 2> /dev/null)"
if [ $? -eq 0 ]; then
    eval "$__conda_setup"
else
    if [ -f "/opt/miniconda3/etc/profile.d/conda.sh" ]; then
        . "/opt/miniconda3/etc/profile.d/conda.sh"
    else
        export PATH="/opt/miniconda3/bin:$PATH"
    fi
fi
unset __conda_setup
```

This block is generated by `conda init` and handles setting up
the Conda environment. The paths are kept platform-aware, though
the initialization block itself uses hardcoded paths that would
need editing on a different machine.

### Project Navigation (ZZCOLLAB)

```sh
_zzcollab_root() {
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -f "$dir/DESCRIPTION" ]] || [[ -f "$dir/.zzcollab_project" ]]; then
            echo "$dir"
            return 0
        fi
        dir="$(dirname "$dir")"
    done
    return 1
}

a() { local root=$(_zzcollab_root); [[ -n "$root" ]] && cd "$root/analysis" || echo "Not in ZZCOLLAB project"; }
s() { local root=$(_zzcollab_root); [[ -n "$root" ]] && cd "$root/analysis/scripts" || echo "Not in ZZCOLLAB project"; }
p() { local root=$(_zzcollab_root); [[ -n "$root" ]] && cd "$root/analysis/report" || echo "Not in ZZCOLLAB project"; }
f() { local root=$(_zzcollab_root); [[ -n "$root" ]] && cd "$root/analysis/figures" || echo "Not in ZZCOLLAB project"; }
r() { local root=$(_zzcollab_root); [[ -n "$root" ]] && cd "$root/R" || echo "Not in ZZCOLLAB project"; }
0() { local root=$(_zzcollab_root); [[ -n "$root" ]] && cd "$root" || echo "Not in ZZCOLLAB project"; }

mr() {
    local root=$(_zzcollab_root)
    [[ -z "$root" ]] && echo "Not in ZZCOLLAB project" && return 1
    [[ ! -f "$root/Makefile" ]] && echo "No Makefile in: $root" && return 1
    make -C "$root" "${@:-r}"
}
```

These functions support a research compendium workflow. From
anywhere inside a project, single-letter commands navigate to
standard directories: `a` for analysis, `s` for scripts, `p` for
the report, `f` for figures, `r` for R source files, and `0` for
the project root. The `mr` function runs Make targets from any
subdirectory.

The `_zzcollab_root` helper walks up the directory tree looking
for a `DESCRIPTION` file (standard R package marker) or a
`.zzcollab_project` file (a project marker). This pattern allows
project-aware commands without hardcoding paths.

---

The numbered sections are deliberate. When adding a new alias,
navigating directly to the aliases section is straightforward.
When a plugin breaks, the plugin management section is the
obvious location. This organisational discipline saves time each
time the file requires editing.

![Git logo](media/images/git-logo.png){.img-fluid width=40%
fig-align="center"}

## Git Configuration

Git is central to the workflow described above: the `gz`
function, the branch display in the prompt, and general version
control. The configuration lives in `~/.gitconfig`.

`~/.gitconfig`:

### User Identity and Defaults

```ini
[init]
    defaultBranch = main

[user]
    name = Your Name
    email = user@example.com

[core]
    editor = nvim
    excludesfile = ~/.gitignore_global
```

The `defaultBranch` setting ensures new repositories start with
`main` rather than `master`. The `excludesfile` points to a
global gitignore that applies to all repositories, useful for
editor backup files, OS metadata like `.DS_Store`, and other
files that should never be committed regardless of project.

### Pull and Merge Behaviour

```ini
[pull]
    rebase = false

[commit]
    quiet = true
```

The setting `rebase = false` preserves merge commits when pulling.
Some teams prefer `rebase = true` for a linear history, but merge
commits are useful for understanding when changes were integrated.
The `quiet = true` setting suppresses the commit summary output,
which is redundant given the `gz` function already shows what was
committed.

### GitHub Authentication

```ini
[credential "https://github.com"]
    helper =
    helper = !/opt/homebrew/bin/gh auth git-credential

[credential "https://gist.github.com"]
    helper =
    helper = !/opt/homebrew/bin/gh auth git-credential
```

Rather than managing SSH keys or personal access tokens
manually, authentication is delegated to the GitHub CLI (`gh`).
After running `gh auth login` once, Git uses `gh` as a
credential helper for all GitHub operations. The empty `helper =`
line clears any previously configured helpers before adding the
`gh` helper.

### Git LFS

```ini
[filter "lfs"]
    clean = git-lfs clean -- %f
    smudge = git-lfs smudge -- %f
    process = git-lfs filter-process
    required = true
```

Git LFS (Large File Storage) handles binary files like datasets,
images, and model weights. This block is added automatically by
`git lfs install`. Files matching patterns in `.gitattributes`
are stored externally and replaced with pointers in the
repository, keeping the repository size manageable.

### Useful Additions

The configuration above is minimal. Consider adding:

```ini
[alias]
    st = status --short
    co = checkout
    br = branch
    lg = log --oneline --graph --decorate -20

[diff]
    colorMoved = default

[merge]
    conflictstyle = diff3
```

The `lg` alias provides a compact visual history. The
`colorMoved` setting highlights moved lines in diffs (useful
when refactoring). The `diff3` conflict style shows the common
ancestor in merge conflicts, making resolution easier.

![Vim logo](media/images/vim.png){.img-fluid width=30%
fig-align="center"}

## Readline Configuration

Many command-line tools (including R, Python's REPL, and various
database clients) use the GNU Readline library for line editing.
By default, Readline uses Emacs-style keybindings, which
conflicts with the vi mode configured in Zsh. The `.inputrc` file
brings consistency across all Readline-based tools.

`~/.inputrc`:

```sh
set editing-mode vi
set show-mode-in-prompt on
set vi-ins-mode-string \1\e[6 q\2
set vi-cmd-mode-string \1\e[2 q\2
```

The `editing-mode vi` setting enables vi keybindings globally.
The mode indicator settings change the cursor shape to signal
which mode you are in: a thin bar in insert mode, a solid block
in command mode. This matches the behaviour of many modern
terminal-based editors.

### Enhanced Completion

```sh
set completion-ignore-case on
set show-all-if-ambiguous on
set colored-stats on
set mark-symlinked-directories on
```

Case-insensitive completion reduces friction when working with
mixed-case filenames. The `show-all-if-ambiguous` setting
displays all matches immediately rather than requiring a second
Tab press. Coloured stats distinguish files from directories in
completion lists, and symlinked directories get a trailing slash
for clarity.

### History Navigation

```sh
set history-preserve-point on
"\e[A": history-search-backward
"\e[B": history-search-forward
```

The `history-preserve-point` setting keeps the cursor position
when navigating history. The key bindings make the up and down
arrows search history for commands starting with whatever has
already been typed, the same behaviour as Zsh's
history-substring-search.

### Bell and Display

```sh
set bell-style none
set enable-bracketed-paste on
```

Disabling the terminal bell removes a disruptive auditory
notification. The bracketed paste setting prevents pasted text
from being interpreted as commands until Enter is pressed, which
is a security feature when pasting from untrusted sources.

---

With these four configuration files (`kitty.conf`, `.zshrc`,
`.gitconfig`, and `.inputrc`), the command-line environment
becomes consistent and efficient across all tools.

# Putting It Together: A Typical Session

With the configuration in place, a typical work session
proceeds as follows:

1. Open Kitty and type `prj` (thanks to `cdpath`, this expands
   to `~/Dropbox/prj`)
2. Type `j analysis` and autojump navigates to the most recent
   analysis project
3. Type `0` to jump to the project root, then `s` for scripts
4. Type `rr`, fzf displays all R files, select one and it opens
   in vim
5. After editing, type `gz` to stage, commit with a conventional
   message, and push
6. To check a plot, `pp` finds and opens the PDF

The individual pieces (cdpath, autojump, fzf functions, the git
workflow) each save a few seconds. Over hundreds of commands per
day, the cumulative effect is significant.

# Checking Our Work: Verifying the Configuration

After copying these configuration files into place, it is worth
verifying that everything loaded correctly.

**Check Kitty settings:**

```bash
kitty --version
kitty +kitten themes --list
```

The first command confirms Kitty is installed. The second lists
available themes, which verifies that the Kitty kitten system is
working.

**Check Zsh and plugins:**

```bash
zsh --version
echo $SHELL
which autojump 2>/dev/null && echo "autojump: loaded" \
  || echo "autojump: not found"
type fzf 2>/dev/null && echo "fzf: loaded" \
  || echo "fzf: not found"
```

**Verify the prompt shows git information:**

```bash
cd /path/to/any/git/repo
# The prompt should display the branch name in red
```

**Test safety aliases:**

```bash
rm test.txt
# Expected output: "This is not the command you are
#   looking for."
```

**Check Git configuration:**

```bash
git config --list --show-origin | head -20
git config user.name
git config user.email
gh auth status
```

The first command shows all settings and where they come from
(useful for debugging). The `gh auth status` confirms GitHub CLI
authentication is working.

**Check Readline (in R or Python):**

```bash
R --quiet
# Press Escape, then 'k' to move up in history (vi command mode)
# Press 'i' to return to insert mode
# Cursor should change shape between modes
```

If the cursor does not change shape, verify that `.inputrc`
exists and that the terminal supports cursor shape changes
(Kitty does; some older terminals do not).

If any plugin fails to load, the `[[ -f ... ]] && source ...`
guards mean Zsh will continue without error. This is deliberate:
a working shell with a missing plugin is preferable to a broken
shell.

## Things to Watch Out For

1. **Duplicate key bindings.** Defining the same Kitty
   keybinding in both basic and data-science sections is a
   common mistake. Kitty uses the last definition, so the
   earlier one is silently ignored. Merging the configuration
   into one file avoids this.

2. **Plugin startup cost.** Loading `zsh-syntax-highlighting`,
   `zsh-autosuggestions`, and `autojump` adds roughly 100-200ms
   to shell startup. If lag appears when opening new terminals,
   profile with `zsh -xv` and consider lazy-loading.

3. **`cdpath` collisions.** If two directories in `cdpath`
   contain subdirectories with the same name, Zsh picks the
   first match. This can cause unexpected navigation to the
   wrong project.

4. **Conda and PATH pollution.** The conda initialisation block
   modifies `$PATH` every time a shell starts. Opening many
   terminal tabs can cause `$PATH` to accumulate duplicate
   entries. Check with `echo $PATH | tr ':' '\n' | sort |
   uniq -d`.

5. **Font fallback on Linux.** FiraCode Nerd Font Mono must be
   installed system-wide on Linux for Kitty to find it. If
   prompt icons render as boxes, run `fc-list | grep -i fira` to
   verify the font is visible to fontconfig.

![A lofi aesthetic workspace with warm lighting and a laptop
screen](media/images/ambiance3.jpg){.img-fluid}

*The calm focus of a well-tuned workspace: what a thoughtfully
configured terminal makes possible.*

## Lessons Learnt

### Conceptual Understanding

- A terminal configuration is a layered system: the emulator
  (Kitty) handles rendering and input; the shell (Zsh) handles
  commands, history, and scripting. Configuring them separately
  keeps each layer clean.
- Scrollback and performance settings are not cosmetic. A
  50,000-line buffer and zero input delay make a tangible
  difference when reviewing long model outputs.
- Directory navigation is a solved problem in Zsh. Between
  `cdpath`, `auto_pushd`, and `autojump`, there is no reason to
  type full paths.
- The prompt is an information display, not decoration. Showing
  git branch and exit status prevents real errors.

### Technical Skills

- Using `vcs_info` for lightweight git integration in the prompt
  avoids the overhead of Oh My Zsh.
- Cross-platform plugin loading via `$OSTYPE` checks allows
  sharing one `.zshrc` between macOS and Linux.
- Combining `ripgrep` with `fzf` for file finding (the `pp`,
  `rr`, and `ff` functions) can replace several GUI tools.
- Kitty's remote control API (`kitty @`) opens possibilities for
  scripting terminal layouts, useful when setting up experiment
  monitoring.

### Gotchas and Pitfalls

- Overriding `rm` with a safety alias means scripts that call
  `rm` will also fail. Use `command rm` or `/bin/rm` in scripts
  when you genuinely need to delete.
- `setopt SHARE_HISTORY` shares history across all terminal
  sessions in real time, which can be disorienting if you are
  not expecting it.
- The `_load_plugin` helper function defined in section 6 is
  currently unused because inline conditionals are more readable
  for three plugins. It would become useful with more plugins.
- Kitty's `background_image` setting accepts an absolute path.
  If the image file moves, Kitty starts with a black background
  and no error message.

## Limitations

- This configuration is tested only on macOS (Sonoma) and
  Ubuntu 22.04. Other distributions may require different
  plugin paths or package names.
- The `.zshrc` includes hardcoded paths (e.g.,
  `/opt/miniconda3`, `/home/z/.autojump`) that will not work
  on other machines without editing.
- The Kitty configuration references a background image at an
  absolute path that is specific to the original machine.
- Plugin loading adds startup latency. For remote servers where
  shell startup time matters (e.g., inside Docker containers),
  a stripped-down `.zshrc` would be more appropriate.
- The `cdpath` approach does not scale well to deeply nested
  project structures with many similarly-named subdirectories.
- No automated testing or linting is applied to these
  configuration files. A typo in `.zshrc` is only caught when
  the shell starts.

## Opportunities for Improvement

1. Store the configuration in a dotfiles repository with a
   symlink-based installer (see the companion post on GitHub
   dotfiles).
2. Replace hardcoded paths with environment variables or
   auto-detection logic to improve portability.
3. Add lazy-loading for plugins to reduce shell startup time
   below 50ms.
4. Integrate with a tiling window manager (Rectangle on macOS,
   i3/Sway on Linux) to automate window positioning alongside
   terminal splits.
5. Add Karabiner-Elements (macOS) or custom keybindings (Linux)
   for a global hotkey to summon Kitty instantly.
6. Write a shell function that profiles `.zshrc` startup time
   and identifies slow sections automatically.

![A lofi workspace with warm ambient lighting](media/images/lofi.jpg){.img-fluid}

*The destination: a command line that works with the user, not
against.*

# Wrapping Up

Configuring a terminal is not glamorous work, but it compounds.
Every alias that saves two seconds, every prompt element that
prevents a mistake, and every navigation shortcut that avoids a
full path adds up across thousands of commands per week.

The most valuable aspect is the organisational discipline:
numbered sections in `.zshrc`, grouped settings in `kitty.conf`,
and consistent vi-mode keybindings across all tools via
`.inputrc`. When something breaks, the location is obvious. When
adding something new, the placement is clear.

For those starting from a default terminal setup, focusing on
four things first is recommended: a Nerd Font for icon support,
`cdpath` for directory navigation, `fzf` for fuzzy file finding,
and `.inputrc` for vi-mode consistency. These changes make the
largest difference in daily workflows.

**Main takeaways:**

- A 50,000-line scrollback buffer prevents losing model training
  output.
- `cdpath` and `auto_pushd` eliminate most `cd ../../..` chains.
- Replacing `rm` with a trash alias prevents accidental data
  loss.
- Cross-platform logic via `$OSTYPE` keeps dotfiles working on
  both macOS and Linux.
- GitHub CLI authentication (`gh auth`) simplifies credential
  management.
- Readline configuration ensures vi-mode works in R, Python, and
  other CLI tools, not just Zsh.

# See Also

**Related posts:**

- [Creating a GitHub Dotfiles Repository for Configuration
  Management](/posts/24-setupdotfilesongithub/): how to
  version-control the files described in this post
- [Setting Up Neovim for Data Science
  Development](/posts/12-configneovim/): the editor layer that
  sits on top of this terminal configuration

**Key resources:**

- [Kitty Terminal Documentation](https://sw.kovidgoyal.net/kitty/):
  the official reference for all configuration options
- [Zsh Documentation](https://zsh.sourceforge.io/Doc/): official
  manual covering options, completion, and scripting
- [Git Configuration](https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration):
  official guide to `.gitconfig` settings
- [GitHub CLI](https://cli.github.com/): the `gh` tool used for
  authentication in this configuration
- [GNU Readline](https://tiswww.case.edu/php/chet/readline/readline.html):
  official documentation for `.inputrc` settings
- [FZF](https://github.com/junegunn/fzf): the fuzzy finder used
  throughout this configuration
- [Ripgrep](https://github.com/BurntSushi/ripgrep): the search
  tool that powers `fzf` file finding here
- [Configuring Zsh Without Dependencies](https://thevaluable.dev/zsh-install-configure-mouseless/):
  an excellent guide to building a Zsh config from scratch

# Reproducibility

**Environment requirements:**

- macOS 10.15+ or Linux (Ubuntu 18.04+, Fedora 30+)
- Zsh 5.0+, Git, Homebrew (macOS)
- FiraCode Nerd Font Mono
- Optional: `fzf`, `ripgrep`, `eza`, `autojump`, `trash-cli`

**Configuration file locations:**

- Kitty: `~/.config/kitty/kitty.conf`
- Zsh: `~/.zshrc`
- Git: `~/.gitconfig`
- Readline: `~/.inputrc`
- Environment secrets: `~/.env` (not version-controlled)

**Version checks:**

```bash
zsh --version
kitty --version
git --version
gh --version      # GitHub CLI
brew --version    # macOS only
fzf --version
rg --version
```

# Feedback

Feedback is welcome for:

- Errors or corrections
- Better approaches to any of these configurations
- Alternative terminal setups
- Questions about adapting this for specific workflows
- General discussion of command-line tools
