---
title: "Configure the Command Line for Data Science Development"
subtitle: "Setting up Kitty terminal, Zsh shell, and
  productivity tools for everyday data science work"
author: "Ronald G. Thomas"
date: "2025-07-24"
categories: [terminal, zsh, macos, configuration, git, neovim]
description: "I didn't really know how much time I was losing
  to default terminal settings until I sat down and configured
  Kitty and Zsh from scratch. Here's what I learned."
image: "media/images/hero.png"
document-type: "blog"
draft: false
execute:
  echo: true
  warning: false
  message: false
format:
  html:
    code-fold: false
    code-tools: false
---

![A terminal emulator showing a customised prompt and colour
scheme](media/images/hero.png){.img-fluid width=80%}

*iTerm2 with a Dracula-inspired colour scheme -- the kind of
environment this post helps you build.*

# Introduction

I didn't really know how much friction a default terminal setup
was adding to my daily work until I watched a colleague navigate
a project in half the keystrokes it took me. His prompt showed
the git branch, his directories auto-completed, and his aliases
turned five-word commands into two characters. I went home that
evening and started rebuilding my shell from the ground up.

That rebuild turned into a months-long process of reading
documentation, trying plugins, breaking things, and gradually
arriving at a configuration that feels natural. This post
documents where I ended up -- a Kitty terminal and Zsh shell
setup tuned for data science workflows on macOS and Linux.

The configuration is opinionated. It reflects the tools I reach
for daily: R, Python, Docker, Git, and fuzzy finders. Your
workflow will differ, but the structural decisions -- how to
organise a `.zshrc`, which Kitty settings actually matter, and
how to keep the whole thing portable -- should transfer.

## Motivations

- I was spending too many keystrokes navigating between project
  directories, and `cd ../../..` chains were getting absurd.
- My default terminal had a 2,000-line scrollback buffer, which
  meant I lost model training output before I could review it.
- I had no visual indicator of which git branch I was on, leading
  to commits on the wrong branch more than once.
- Plugin installation felt like guesswork -- I wanted a
  cross-platform loading strategy that worked on both my Mac and
  my Linux server.
- I kept accumulating aliases in random places and needed a
  single, well-organised configuration file.
- I wanted Kitty's image protocol for viewing matplotlib plots
  directly in the terminal, rather than switching to a file
  manager.

## Objectives

1. Install and configure Kitty terminal with a merged
   configuration covering fonts, colours, performance, and
   data-science-specific settings.
2. Set up Zsh with a modular `.zshrc` that handles environment
   variables, history, completion, prompts, plugins, aliases, and
   custom functions in clearly separated sections.
3. Implement productivity shortcuts -- directory jumping,
   fzf-powered file finding, and safety aliases -- that reduce
   repetitive typing.
4. Configure cross-platform plugin loading so the same `.zshrc`
   works on macOS and Linux without modification.

I'm documenting my learning process here. If you spot errors or
have better approaches, please let me know.

![](media/images/terminal-logo.png){.img-fluid width=30% fig-align="center"}

*A well-configured editor and terminal working together --
the goal of this entire setup.*

# Prerequisites and Setup

This post assumes you have administrative privileges on a macOS
or Linux machine and are comfortable running commands in a
terminal. You will need:

- **macOS**: Homebrew (`brew`) installed
- **Linux**: A system package manager (apt, dnf, or pacman)
- **Both**: Git and Zsh 5.0+

**macOS installation:**

```bash
brew install kitty
```

**Linux installation:**

```bash
# Ubuntu/Debian
sudo apt-get install kitty

# Fedora/RHEL
sudo dnf install kitty

# Arch Linux
sudo pacman -S kitty
```

Kitty stores its configuration in `~/.config/kitty/kitty.conf`.
Zsh reads `~/.zshrc` at startup. Both files are plain text and
can be version-controlled in a dotfiles repository.

# What is Kitty?

Kitty is a GPU-accelerated terminal emulator written in C and
Python. Unlike traditional terminals, it offloads rendering to
the GPU, which makes scrolling through large outputs noticeably
smoother. Its main appeal for data science work is the built-in
graphics protocol: you can display images, plots, and charts
directly in the terminal window using `kitten icat` or
backend libraries like `matplotlib-backend-kitty`.

Think of Kitty as a terminal that understands pictures. Where a
standard terminal can only show text, Kitty can render a
matplotlib scatter plot inline, right below the command that
generated it.

# Getting Started: Kitty Terminal Configuration

The configuration file below is a single, merged `kitty.conf`.
I started with a basic setup and gradually added data-science
specific settings over several weeks. The comments explain the
reasoning behind each group of settings.

`~/.config/kitty/kitty.conf`:

```sh
# Font -- FiraCode Nerd Font for ligatures and icon support
font_family FiraCode Nerd Font Mono
font_size 14.0

# Cursor -- disable blinking to reduce visual noise
cursor_blink_interval 0

# Scrollback -- 50k lines for reviewing long model outputs
scrollback_lines 50000
scrollback_pager less --chop-long-lines --RAW-CONTROL-CHARS \
  +INPUT_LINE_NUMBER
scrollback_fill_enlarged_window yes

# Performance -- low latency for streaming log output
repaint_delay 2
input_delay 0
sync_to_monitor yes

# Terminal bell -- audio notification for long-running jobs
enable_audio_bell yes

# Window layout
initial_window_width  1024
initial_window_height 768
window_padding_width 4
draw_minimal_borders yes

# Tab bar
tab_bar_edge bottom
tab_bar_style powerline
tab_powerline_style slanted

# Colour scheme (Dracula theme)
foreground            #f8f8f2
background            #282a36
selection_foreground  #ffffff
selection_background  #44475a

color0  #21222c
color8  #6272a4
color1  #ff5555
color9  #ff6e6e
color2  #50fa7b
color10 #69ff94
color3  #f1fa8c
color11 #ffffa5
color4  #bd93f9
color12 #d6acff
color5  #ff79c6
color13 #ff92df
color6  #8be9fd
color14 #a4ffff
color7  #f8f8f2
color15 #ffffff

cursor            #f8f8f2
cursor_text_color #282a36

# Tab colours
active_tab_foreground   #282a36
active_tab_background   #f8f8f2
inactive_tab_foreground #282a36
inactive_tab_background #6272a4

# Appearance
background_opacity 0.99
window_margin_width 5
window_border_width 1.5pt
include current-theme.conf

# Key bindings -- splits and tabs
map cmd+d launch --location=vsplit --cwd=current
map cmd+shift+d launch --location=hsplit --cwd=current
map shift+ctrl+d launch --location=hsplit --cwd=current
map cmd+w close_window
map cmd+shift+w close_tab
map cmd+t new_tab
map cmd+shift+] next_tab
map cmd+shift+[ previous_tab

# Key bindings -- tab switching
map cmd+1 goto_tab 1
map cmd+2 goto_tab 2
map cmd+3 goto_tab 3
map cmd+4 goto_tab 4
map cmd+5 goto_tab 5

# Key bindings -- zoom and layout
map cmd+plus change_font_size all +2.0
map cmd+minus change_font_size all -2.0
map cmd+0 change_font_size all 0
map ctrl+shift+z toggle_layout stack

# Key bindings -- fullscreen and positioning
map shift+ctrl+f toggle_fullscreen
map shift+ctrl+r set_window_position right
map shift+ctrl+l set_window_position left

# Key bindings -- data science utilities
map ctrl+shift+h show_scrollback
map ctrl+shift+i kitten icat

# Clipboard
map cmd+c copy_to_clipboard
map cmd+v paste_from_clipboard
copy_on_select clipboard

# URL detection for dataset links and documentation
detect_urls yes

# Remote control for programmatic terminal management
allow_remote_control yes
```

The settings that made the largest difference for me were
`scrollback_lines 50000` (I no longer lose model training
output), `input_delay 0` (the terminal feels instant when
monitoring long-running processes), and `copy_on_select
clipboard` (selecting text copies it automatically, which saves
a surprising number of keystrokes per day).

Kitty's graphics protocol deserves a brief mention. After
installing `matplotlib-backend-kitty` (`pip install
matplotlib-backend-kitty`), you can set the environment variable
`MPLBACKEND=module://matplotlib-backend-kitty` and matplotlib
plots will render inline. For quick image inspection, `kitten
icat plot.png` displays any image directly in the terminal. I
use this constantly when reviewing generated figures.

![Neofetch system information displayed in a
terminal](media/images/ambiance2.png){.img-fluid}

*System information via neofetch -- a quick way to verify your
terminal's font rendering and colour support.*

## Zsh Shell Configuration

With Kitty configured, the next layer is the shell itself. My
`.zshrc` is organised into ten numbered sections. Each section
handles one concern, which makes it straightforward to find and
modify settings.

The full file is below.

`~/.zshrc`:

```sh
# 1. ENVIRONMENT & SECURITY
[[ -f ~/.env ]] && source ~/.env

# 2. CORE SHELL CONFIGURATION
export EDITOR="vim"
export DOCKER_BUILDKIT=1
export HOMEBREW_AUTO_UPDATE_SECS="604800"
export GITHUB_USER="rgt47"
export TEXINPUTS='.:$HOME/shr/images:$HOME/shr:'
export BIBINPUTS='.:$HOME/shr/bibfiles:$HOME/shr'
export PATH=".:$HOME/bin:$HOME/.local/bin:\
/opt/homebrew/bin:/opt/homebrew/sbin:$PATH"

cdpath=($HOME/Dropbox $HOME/Dropbox/prj \
  $HOME/Dropbox/sbx $HOME/Dropbox/work)

setopt auto_cd auto_pushd pushd_ignore_dups pushdminus
setopt PROMPT_SUBST
bindkey -v

# 3. HISTORY MANAGEMENT
HISTFILE="$HOME/.zsh_history"
HISTSIZE=100000
SAVEHIST=100000
setopt SHARE_HISTORY HIST_IGNORE_DUPS \
  INC_APPEND_HISTORY HIST_VERIFY

# 4. COMPLETION & NAVIGATION
autoload -U compinit && compinit -u
compdef _dirs d

# 5. PROMPT & VCS INTEGRATION
autoload -Uz vcs_info
precmd() { vcs_info }
zstyle ':vcs_info:git:*' formats '%b '
PROMPT='%F{green}%*%f %F{yellow}${${PWD:A}/$HOME/~}%f \
%F{red}${vcs_info_msg_0_}%f$ %(?:☕  :☔  )'

# 6. PLUGIN MANAGEMENT
_load_plugin() {
    local plugin_name=$1
    local linux_path=$2
    local macos_path=$3
    if [[ "$OSTYPE" == "linux-gnu"* \
      && -f "$linux_path" ]]; then
        source "$linux_path"
    elif [[ "$OSTYPE" == "darwin"* \
      && -f "$macos_path" ]]; then
        source "$macos_path"
    fi
}

if [[ "$OSTYPE" == "linux-gnu"* ]]; then
    [[ -s /home/z/.autojump/etc/profile.d/autojump.sh \
      ]] && source /home/z/.autojump/etc/profile.d/\
autojump.sh
    [[ -f ~/.zsh/zsh-autosuggestions/\
zsh-autosuggestions.zsh ]] && \
      source ~/.zsh/zsh-autosuggestions/\
zsh-autosuggestions.zsh
    [[ -f ~/.zsh/zsh-syntax-highlighting/\
zsh-syntax-highlighting.zsh ]] && \
      source ~/.zsh/zsh-syntax-highlighting/\
zsh-syntax-highlighting.zsh
elif [[ "$OSTYPE" == "darwin"* ]]; then
    BREW_PREFIX=$(brew --prefix)
    [[ -f $BREW_PREFIX/etc/profile.d/autojump.sh \
      ]] && source $BREW_PREFIX/etc/profile.d/autojump.sh
    [[ -f $BREW_PREFIX/share/zsh-autosuggestions/\
zsh-autosuggestions.zsh ]] && \
      source $BREW_PREFIX/share/zsh-autosuggestions/\
zsh-autosuggestions.zsh
    [[ -f $BREW_PREFIX/share/zsh-syntax-highlighting/\
zsh-syntax-highlighting.zsh ]] && \
      source $BREW_PREFIX/share/zsh-syntax-highlighting/\
zsh-syntax-highlighting.zsh
fi

ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=red,bold,underline'

# 7. TOOL-SPECIFIC CONFIGURATION
if type rg &> /dev/null; then
    export FZF_DEFAULT_COMMAND='rg --files --hidden'
    export FZF_DEFAULT_OPTS=\
'-m --height 50% --border --reverse'
fi

# 8. ALIASES
alias -- -='cd -'
alias -g ...='../..'
alias ls='ls --color=auto'
alias ll='ls -lh --color=auto'
alias lt='eza -lrha -sold'
alias grep='grep --color=auto'
alias diff='diff --color=auto'
alias za=zathura
alias hh=history
alias R='R --quiet --no-save'
alias mm='mutt'
alias v='vim'
alias ZZ='exit'
alias vc='vim ~/.vimrc'
alias vz='vim ~/Dropbox/dotfiles/zsh_eval'
alias sz='source ~/Dropbox/dotfiles/zsh_eval'
alias tp='trash-put -v'
alias rm='echo "This is not the command you are \
looking for."; false'
alias pp='zathura $(rg --files | rg "\.pdf$" | fzf)'
alias rr='vim $(rg --files | rg "\.(R|Rmd)$" | fzf)'

if [[ "$OSTYPE" == "darwin"* ]]; then
    alias sk='open -a Skim'
    alias claude="/Users/zenn/.claude/local/claude"
fi

# 9. CUSTOM FUNCTIONS
d() {
    if [[ -n $1 ]]; then
        dirs "$@"
    else
        dirs -v | head -n 10
    fi
}

ff() {
    local file
    file=$(rg --files "${1:-.}" 2>/dev/null \
      | fzf --select-1 --exit-0) \
      && cd "$(dirname "$file")"
}

if [[ "$OSTYPE" == "darwin"* ]]; then
    mma() {
        /Applications/Mathematica.app/Contents/\
MacOS/WolframKernel -script $1
    }
fi

# 10. EXTERNAL TOOL INTEGRATION
# >>> conda initialize >>>
__conda_setup="$('/opt/miniconda3/bin/conda' \
  'shell.zsh' 'hook' 2> /dev/null)"
if [ $? -eq 0 ]; then
    eval "$__conda_setup"
else
    if [ -f "/opt/miniconda3/etc/profile.d/conda.sh" ]
    then
        . "/opt/miniconda3/etc/profile.d/conda.sh"
    else
        export PATH="/opt/miniconda3/bin:$PATH"
    fi
fi
unset __conda_setup
# <<< conda initialize <<<
```

The numbered sections are deliberate. When I need to add a new
alias, I go straight to section 8. When a plugin breaks, I look
at section 6. This organisational discipline saves time every
time I edit the file.

# Building a Workflow: Aliases and Functions in Practice

The aliases and functions in sections 8 and 9 above are the
core of my daily command-line experience. Here I want to explain
the thinking behind the ones I reach for most.

**Safety aliases.** I replaced `rm` with an error message
(`alias rm='echo "This is not the command you are looking for.";
false'`) and use `trash-put` via `tp` instead. After
accidentally deleting a dataset early in my career, I decided
that `rm` should never silently succeed. The alias forces me to
use `tp`, which moves files to the trash rather than destroying
them.

**Fuzzy finding.** The `pp` and `rr` aliases combine `ripgrep`
with `fzf` to locate PDF files and R scripts, respectively. I
type `pp`, a fuzzy search window appears listing every PDF in
the current directory tree, and I select one to open in Zathura.
The `ff` function does the same but changes directory to
wherever the selected file lives.

**Directory navigation.** The `cdpath` variable is one of the
most underrated Zsh features I have encountered. By setting
`cdpath=($HOME/Dropbox $HOME/Dropbox/prj)`, I can type
`cd myproject` from anywhere and Zsh will find it inside
`~/Dropbox/prj/myproject` without a full path. Combined with
`auto_cd` (which lets me type a directory name without `cd`)
and `auto_pushd` (which maintains a directory stack accessible
via `d`), navigation becomes almost frictionless.

**The prompt.** My prompt shows the current time (green), the
working directory (yellow), the git branch (red), and a status
indicator: a coffee cup if the last command succeeded, a rain
cloud if it failed. The git branch display alone has saved me
from committing to the wrong branch dozens of times.

# Checking Our Work: Verifying the Configuration

After copying these configuration files into place, it is worth
verifying that everything loaded correctly.

**Check Kitty settings:**

```bash
kitty --version
kitty +kitten themes --list
```

The first command confirms Kitty is installed. The second lists
available themes, which verifies that the Kitty kitten system is
working.

**Check Zsh and plugins:**

```bash
zsh --version
echo $SHELL
which autojump 2>/dev/null && echo "autojump: loaded" \
  || echo "autojump: not found"
type fzf 2>/dev/null && echo "fzf: loaded" \
  || echo "fzf: not found"
```

**Verify the prompt shows git information:**

```bash
cd /path/to/any/git/repo
# The prompt should display the branch name in red
```

**Test safety aliases:**

```bash
rm test.txt
# Expected output: "This is not the command you are
#   looking for."
```

If any plugin fails to load, the `[[ -f ... ]] && source ...`
guards in section 6 mean Zsh will continue without error. This
is deliberate: I would rather have a working shell with a
missing plugin than a broken shell.

## Things to Watch Out For

1. **Duplicate key bindings.** I initially defined the same
   Kitty keybinding in both the basic and data-science sections
   of my config. Kitty uses the last definition, so the earlier
   one was silently ignored. Merge your config into one file to
   avoid this.

2. **Plugin startup cost.** Loading `zsh-syntax-highlighting`,
   `zsh-autosuggestions`, and `autojump` adds roughly 100-200ms
   to shell startup. If you notice lag when opening new
   terminals, profile with `zsh -xv` and consider lazy-loading.

3. **`cdpath` collisions.** If two directories in your `cdpath`
   contain subdirectories with the same name, Zsh picks the
   first match. I once spent twenty minutes wondering why `cd
   data` took me to the wrong project.

4. **Conda and PATH pollution.** The conda initialisation block
   modifies `$PATH` every time a shell starts. If you open many
   terminal tabs, check that `$PATH` has not accumulated
   duplicate entries with `echo $PATH | tr ':' '\n' | sort |
   uniq -d`.

5. **Font fallback on Linux.** FiraCode Nerd Font Mono must be
   installed system-wide on Linux for Kitty to find it. If
   prompt icons render as boxes, run `fc-list | grep -i fira` to
   verify the font is visible to fontconfig.

![A lofi aesthetic workspace with warm lighting and a laptop
screen](media/images/ambiance3.jpg){.img-fluid}

*The calm focus of a well-tuned workspace -- what a
thoughtfully configured terminal makes possible.*

## Lessons Learnt

### Conceptual Understanding

- A terminal configuration is a layered system: the emulator
  (Kitty) handles rendering and input; the shell (Zsh) handles
  commands, history, and scripting. Configuring them separately
  keeps each layer clean.
- Scrollback and performance settings are not cosmetic. A
  50,000-line buffer and zero input delay make a tangible
  difference when reviewing long model outputs.
- Directory navigation is a solved problem in Zsh. Between
  `cdpath`, `auto_pushd`, and `autojump`, there is no reason to
  type full paths.
- The prompt is an information display, not decoration. Showing
  git branch and exit status prevents real errors.

### Technical Skills

- I learnt to use `vcs_info` for lightweight git integration in
  the prompt, avoiding the overhead of Oh My Zsh.
- Cross-platform plugin loading via `$OSTYPE` checks lets me
  share one `.zshrc` between macOS and Linux.
- Combining `ripgrep` with `fzf` for file finding (the `pp`,
  `rr`, and `ff` functions) replaced several GUI tools I used
  to depend on.
- Kitty's remote control API (`kitty @`) opens possibilities
  for scripting terminal layouts, which I use when setting up
  experiment monitoring.

### Gotchas and Pitfalls

- Overriding `rm` with a safety alias means scripts that call
  `rm` will also fail. Use `command rm` or `/bin/rm` in scripts
  when you genuinely need to delete.
- `setopt SHARE_HISTORY` shares history across all terminal
  sessions in real time, which can be disorienting if you are
  not expecting it.
- The `_load_plugin` helper function defined in section 6 is
  currently unused because I found inline conditionals more
  readable for three plugins. It would become useful with more
  plugins.
- Kitty's `background_image` setting accepts an absolute path.
  If the image file moves, Kitty starts with a black background
  and no error message.

## Limitations

- This configuration is tested only on macOS (Sonoma) and
  Ubuntu 22.04. Other distributions may require different
  plugin paths or package names.
- The `.zshrc` includes hardcoded paths (e.g.,
  `/opt/miniconda3`, `/home/z/.autojump`) that will not work
  on other machines without editing.
- The Kitty configuration references a background image at an
  absolute path that is specific to my machine.
- Plugin loading adds startup latency. For remote servers where
  shell startup time matters (e.g., inside Docker containers),
  a stripped-down `.zshrc` would be more appropriate.
- The `cdpath` approach does not scale well to deeply nested
  project structures with many similarly-named subdirectories.
- No automated testing or linting is applied to these
  configuration files. A typo in `.zshrc` is only caught when
  the shell starts.

## Opportunities for Improvement

1. Store the configuration in a dotfiles repository with a
   symlink-based installer (see my companion post on GitHub
   dotfiles).
2. Replace hardcoded paths with environment variables or
   auto-detection logic to improve portability.
3. Add lazy-loading for plugins to reduce shell startup time
   below 50ms.
4. Integrate with a tiling window manager (Rectangle on macOS,
   i3/Sway on Linux) to automate window positioning alongside
   terminal splits.
5. Add Karabiner-Elements (macOS) or custom keybindings (Linux)
   for a global hotkey to summon Kitty instantly.
6. Write a shell function that profiles `.zshrc` startup time
   and identifies slow sections automatically.

# Wrapping Up

Configuring a terminal is not glamorous work, but it compounds.
Every alias that saves two seconds, every prompt element that
prevents a mistake, and every navigation shortcut that avoids a
full path -- they add up across thousands of commands per week.

What I found most valuable was the organisational discipline:
ten numbered sections in `.zshrc`, one merged `kitty.conf`, and
a clear separation between the terminal emulator and the shell.
When something breaks, I know exactly where to look. When I want
to add something new, I know exactly where to put it.

If you are starting from a default terminal setup, I would
suggest focusing on three things first: a Nerd Font for icon
support, `cdpath` for directory navigation, and `fzf` for fuzzy
file finding. Those three changes alone made the biggest
difference in my daily workflow.

**Main takeaways:**

- A 50,000-line scrollback buffer prevents losing model training
  output.
- `cdpath` and `auto_pushd` eliminate most `cd ../../..` chains.
- Replacing `rm` with a trash alias prevents accidental data
  loss.
- Cross-platform plugin loading via `$OSTYPE` keeps one `.zshrc`
  working on both macOS and Linux.

# See Also

**Related posts:**

- [Creating a GitHub Dotfiles Repository for Configuration
  Management](/posts/24-setupdotfilesongithub/) -- how to
  version-control the files described in this post
- [Setting Up Neovim for Data Science
  Development](/posts/12-configneovim/) -- the editor layer
  that sits on top of this terminal configuration

**Key resources:**

- [Kitty Terminal Documentation](https://sw.kovidgoyal.net/kitty/)
  -- the official reference for all configuration options
- [Zsh Documentation](https://zsh.sourceforge.io/Doc/) --
  official manual covering options, completion, and scripting
- [FZF](https://github.com/junegunn/fzf) -- the fuzzy finder
  used throughout this configuration
- [Ripgrep](https://github.com/BurntSushi/ripgrep) -- the
  search tool that powers `fzf` file finding here
- [Configuring Zsh Without Dependencies](https://thevaluable.dev/zsh-install-configure-mouseless/)
  -- an excellent guide to building a Zsh config from scratch

# Reproducibility

**Environment requirements:**

- macOS 10.15+ or Linux (Ubuntu 18.04+, Fedora 30+)
- Zsh 5.0+, Git, Homebrew (macOS)
- FiraCode Nerd Font Mono
- Optional: `fzf`, `ripgrep`, `eza`, `autojump`, `trash-cli`

**Configuration file locations:**

- Kitty: `~/.config/kitty/kitty.conf`
- Zsh: `~/.zshrc`
- Environment secrets: `~/.env` (not version-controlled)

**Version checks:**

```bash
zsh --version
kitty --version
brew --version    # macOS only
fzf --version
rg --version
```

# Let's Connect

- **GitHub**: [rgt47](https://github.com/rgt47)
- **Twitter/X**: [@rgt47](https://twitter.com/rgt47)
- **LinkedIn**: [Ronald Glenn Thomas](https://linkedin.com/in/rgthomaslab)
- **Email**: [Contact through website](https://rgtlab.org/contact)

I would enjoy hearing from you if you:

- Spot an error or have a correction
- Have a better approach to any of these configurations
- Want to share your own terminal setup
- Have questions about adapting this for a specific workflow
- Just want to connect and talk about command-line tools
