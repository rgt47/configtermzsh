---
title: "Configure the Command Line for Data Science Development"
subtitle: "Setting up Kitty terminal, Zsh shell, and
  productivity tools for everyday data science work"
author: "Ronald G. Thomas"
date: "2026-02-16"
categories: [terminal, zsh, macos, configuration, git, neovim]
description: "I didn't really know how much time I was losing
  to default terminal settings until I sat down and configured
  Kitty and Zsh from scratch. Here's what I learned."
image: "media/images/hero.png"
document-type: "blog"
draft: false
execute:
  echo: true
  warning: false
  message: false
format:
  html:
    code-fold: false
    code-tools: false
---

![A kitty terminal emulator showing a customised prompt and colour
scheme](media/images/hero.png){.img-fluid width=80%}

*kitty with a Dracula-inspired colour scheme -- the kind of
environment this post helps you build.*

# Introduction


The configuration is opinionated. It reflects the tools I reach
for daily: R, Python, Docker, Git, and fuzzy finders. Your
workflow will differ, but the structural decisions -- how to
organise a `.zshrc`, which Kitty settings actually matter, and
how to keep the whole thing portable -- should transfer.

## Motivations

- I was spending too many keystrokes navigating between project
  directories, and `cd ../../..` chains were getting absurd.
- My default terminal had a 2,000-line scrollback buffer, which
  meant I lost model training output before I could review it.
- I had no visual indicator of which git branch I was on, leading
  to commits on the wrong branch more than once.
- Plugin installation felt like guesswork -- I wanted a
  cross-platform loading strategy that worked on both my Mac and
  my Linux server.
- I kept accumulating aliases in random places and needed a
  single, well-organised configuration file.
- I wanted Kitty's image protocol for viewing matplotlib plots
  directly in the terminal, rather than switching to a file
  manager.

## Objectives

1. Install and configure Kitty terminal with a merged
   configuration covering fonts, colours, performance, and
   data-science-specific settings.
2. Set up Zsh with a modular `.zshrc` that handles environment
   variables, history, completion, prompts, plugins, aliases, and
   custom functions in clearly separated sections.
3. Implement productivity shortcuts -- directory jumping,
   fzf-powered file finding, and safety aliases -- that reduce
   repetitive typing.
4. Configure cross-platform plugin loading so the same `.zshrc`
   works on macOS and Linux without modification.

I'm documenting my learning process here. If you spot errors or
have better approaches, please let me know.

![](media/images/terminal-logo.png){.img-fluid width=30% fig-align="center"}

*A well-configured editor and terminal working together --
the goal of this entire setup.*

# Prerequisites and Setup

This post assumes you have administrative privileges on a macOS
or Linux machine and are comfortable running commands in a
terminal. You will need:

- **macOS**: Homebrew (`brew`) installed
- **Linux**: A system package manager (apt, dnf, or pacman)
- **Both**: Git and Zsh 5.0+

**macOS installation:**

```bash
brew install kitty
```

**Linux installation:**

```bash
# Ubuntu/Debian
sudo apt-get install kitty

# Fedora/RHEL
sudo dnf install kitty

# Arch Linux
sudo pacman -S kitty
```

Kitty stores its configuration in `~/.config/kitty/kitty.conf`.
Zsh reads `~/.zshrc` at startup. Both files are plain text and
can be version-controlled in a dotfiles repository.

# What is Kitty?

Kitty is a GPU-accelerated terminal emulator written in C and
Python. Unlike traditional terminals, it offloads rendering to
the GPU, which makes scrolling through large outputs noticeably
smoother. Its main appeal for data science work is the built-in
graphics protocol: you can display images, plots, and charts
directly in the terminal window using `kitten icat` or
backend libraries like `matplotlib-backend-kitty`.

Think of Kitty as a terminal that understands pictures. Where a
standard terminal can only show text, Kitty can render a
matplotlib scatter plot inline, right below the command that
generated it.

# Getting Started: Kitty Terminal Configuration

The configuration below is my complete `kitty.conf`, built up
over several weeks. Rather than present it as a single block, I
will walk through each section and explain the reasoning behind
the settings.

`~/.config/kitty/kitty.conf`:

## Cursor and Basic Behaviour

```sh
cursor_shape block
cursor_blink_interval 0
```

I prefer a solid block cursor with no blinking. The blinking
cursor is distracting when reading code, and disabling it
removes one source of visual noise. Some people prefer
`cursor_shape beam` for a thinner insertion point, but I find
the block easier to locate after looking away from the screen.

## Scrollback Buffer

```sh
scrollback_lines 50000
scrollback_pager less --chop-long-lines --RAW-CONTROL-CHARS +INPUT_LINE_NUMBER
scrollback_fill_enlarged_window yes
```

The default scrollback of 2,000 lines is inadequate for data
science work. Model training runs, database query results, and
error traces routinely exceed that limit. I increased this to
50,000 lines, which covers most of my workflows without
consuming excessive memory.

The `scrollback_pager` setting lets me open the entire terminal
history in `less` by pressing `Ctrl+Shift+H`. This is invaluable
when I need to search through a long training log for a specific
metric or error message. The `+INPUT_LINE_NUMBER` flag positions
the pager at the current scroll position rather than the top.

## Performance Tuning

```sh
repaint_delay 2
input_delay 0
sync_to_monitor yes
```

These settings reduce latency when the terminal is updating
rapidly. With `input_delay 0`, keystrokes register immediately
even when a long-running process is flooding the screen with
output. The `repaint_delay 2` (milliseconds) keeps the display
smooth when streaming data through command-line tools.

I keep `sync_to_monitor yes` to avoid screen tearing, but if you
notice lag during intensive output, setting it to `no` can help.
The trade-off is occasional visual artifacts during rapid
scrolling.

## Window Layout and Padding

```sh
initial_window_width  1024
initial_window_height 768
window_padding_width 4
window_margin_width 5
window_border_width 2pt
inactive_border_width 1pt
draw_minimal_borders yes
```

The initial window size gives me a reasonable starting point
that I then resize as needed. The padding and margin settings
add breathing room around the terminal content, which reduces
eye strain during long sessions. Minimal borders keep the
interface clean when using split panes.

## Tab Bar Appearance

```sh
tab_bar_edge bottom
tab_bar_style powerline
tab_powerline_style slanted
```

I place the tab bar at the bottom because my eyes naturally rest
in the lower half of the screen when typing. The powerline style
with slanted separators provides clear visual distinction between
tabs without being distracting.

## Basic Key Bindings

```sh
map cmd+d launch --location=vsplit --cwd=current
map cmd+w close_window
map cmd+shift+w close_tab
map cmd+t new_tab
map cmd+shift+] next_tab
map cmd+shift+[ previous_tab

map cmd+1 goto_tab 1
map cmd+2 goto_tab 2
map cmd+3 goto_tab 3
map cmd+4 goto_tab 4
map cmd+5 goto_tab 5
```

These bindings mirror what I expect from other macOS
applications. `Cmd+D` splits the current pane vertically (the
`--cwd=current` flag ensures the new pane starts in the same
directory). The tab shortcuts let me jump directly to a specific
tab without cycling through them.

## Zoom and Font Size

```sh
map cmd+plus change_font_size all +2.0
map cmd+minus change_font_size all -2.0
map cmd+0 change_font_size all 0
map ctrl+shift+z toggle_layout stack
map f11 toggle_layout stack
```

Quick font resizing is essential when sharing my screen or
reading dense output. The `toggle_layout stack` binding
temporarily maximises the current pane, which is useful when I
need to focus on one window without closing others.

## Clipboard Integration

```sh
map cmd+c copy_to_clipboard
map cmd+v paste_from_clipboard
copy_on_select clipboard
```

The `copy_on_select clipboard` setting is a significant
time-saver. Selecting text with the mouse automatically copies
it to the clipboard, eliminating the extra `Cmd+C` keystroke. I
use this constantly when copying error messages or code snippets.

## Remote Control and Shell Integration

```sh
allow_remote_control yes
listen_on unix:/tmp/kitty
```

Remote control lets me script Kitty from the command line. For
example, I can set window titles programmatically to track
different experiments:

```bash
kitty @ set-window-title "Model-XGBoost-Experiment-1"
```

This is particularly useful when running multiple training jobs
and I need to identify which terminal corresponds to which
experiment.

## Font Configuration

```sh
font_size 14.0
font_family      JetBrainsMono Nerd Font Mono
bold_font        JetBrainsMono Nerd Font Mono Extra Bold
bold_italic_font JetBrainsMono Nerd Font Mono Extra Bold Italic
```

I use JetBrains Mono because it renders clearly at small sizes
and includes programming ligatures that make operators like `!=`
and `>=` more readable. The Nerd Font variant adds icons used by
many command-line tools and prompt themes. At 14pt, the font is
comfortable for extended reading without wasting screen space.

## Data Science Key Bindings

```sh
map ctrl+shift+h show_scrollback
map ctrl+shift+i kitten icat
map cmd+shift+d launch --location=hsplit --cwd=current
map f8 launch --location=vsplit --cwd=current
map f10 launch --type=os-window
map f12 next_window
map f9 next_layout
map ctrl+shift+l no_op
```

These bindings support my data science workflow specifically.
`Ctrl+Shift+H` opens the scrollback in the pager for searching
through training logs. `Ctrl+Shift+I` launches `kitten icat` for
viewing images directly in the terminal (useful for quick plot
inspection). The split bindings (`Cmd+Shift+D` for horizontal,
`F8` for vertical) let me monitor a training run in one pane
while continuing to work in another.

## URL Detection and Notifications

```sh
detect_urls yes
enable_audio_bell yes
```

URL detection makes it easy to open links to documentation,
datasets, and GitHub repositories by clicking on them. The audio
bell provides a notification when long-running processes
complete. I often append `&& echo -e '\a'` to training commands
so I hear when they finish.

## macOS-Specific Settings

```sh
macos_option_as_alt yes
macos_quit_when_last_window_closed yes
confirm_os_window_close 1
```

On macOS, `macos_option_as_alt` lets me use Option as the Alt
key, which is necessary for many terminal applications that
expect Alt+key combinations. The quit and confirm settings
prevent accidental closure of important terminal sessions.

## Theme

```sh
# BEGIN_KITTY_THEME
# 3024 Night
include current-theme.conf
# END_KITTY_THEME
```

I use a dark theme (3024 Night) stored in a separate file. Kitty
manages this through its theme system, which makes it easy to
switch themes without editing the main configuration. Run
`kitty +kitten themes` to browse and install themes.

---

The settings that made the largest difference for me were
`scrollback_lines 50000` (I no longer lose model training
output), `input_delay 0` (the terminal feels instant when
monitoring long-running processes), and `copy_on_select
clipboard` (selecting text copies it automatically, which saves
a surprising number of keystrokes per day).

Kitty's graphics protocol deserves a brief mention. After
installing `matplotlib-backend-kitty` (`pip install
matplotlib-backend-kitty`), you can set the environment variable
`MPLBACKEND=module://matplotlib-backend-kitty` and matplotlib
plots will render inline. For quick image inspection, `kitten
icat plot.png` displays any image directly in the terminal. I
use this constantly when reviewing generated figures.

![Neofetch system information displayed in a
terminal](media/images/ambiance2.png){.img-fluid}

*System information via neofetch -- a quick way to verify your
terminal's font rendering and colour support.*

## Zsh Shell Configuration

With Kitty configured, the next layer is the shell itself. My
`.zshrc` is organised into twelve numbered sections, each
handling one concern. I will walk through each section and
explain the reasoning.

A key design principle: every optional dependency is wrapped in
a conditional check. If a tool like `autojump` or `ripgrep` is
not installed, the configuration degrades gracefully rather than
throwing errors.

`~/.zshrc`:

### Environment and Security

```sh
[[ -f ~/.env ]] && source ~/.env
```

Sensitive information (API keys, tokens, database credentials)
lives in a separate `~/.env` file that is not version-controlled.
This single line sources it if it exists and does nothing if it
does not. I never commit secrets to my dotfiles repository.

### Core Shell Configuration

```sh
export EDITOR="vim"
export VIMINIT='source ~/.config/vim/vimrc'
export DOCKER_BUILDKIT=1
export GITHUB_USER="rgt47"

export TEXINPUTS=".:$HOME/shr/images:$HOME/shr:"
export BIBINPUTS=".:$HOME/shr/bibfiles:$HOME/shr"
```

These exports set my default editor and configure paths for
LaTeX. The `DOCKER_BUILDKIT=1` enables Docker's improved build
system, which provides better caching and parallel builds. The
`GITHUB_USER` variable is used by various scripts that interact
with GitHub.

### Platform-Specific PATH Configuration

```sh
if [[ "$OSTYPE" == "darwin"* ]]; then
    export HOMEBREW_AUTO_UPDATE_SECS="604800"
    export PATH="$HOME/bin:$HOME/.local/bin:/opt/homebrew/bin:/opt/homebrew/sbin:$PATH"
else
    export PATH="$HOME/bin:$HOME/.local/bin:$PATH"
fi
```

This is the first example of cross-platform logic. On macOS, I
include Homebrew's paths and throttle automatic updates to once
per week (604800 seconds). On Linux, I skip the Homebrew paths
since they do not exist. The `$OSTYPE` variable is set by Zsh
and reliably distinguishes between operating systems.

Note the security fix: I removed a leading `.` from PATH that
was present in an earlier version. Having `.` in PATH means the
shell will execute programs in the current directory, which is a
security risk if you `cd` into an untrusted directory.

### Core Shell Options

```sh
cdpath=($HOME/Dropbox $HOME/Dropbox/prj $HOME/Dropbox/sbx $HOME/Dropbox/work)

setopt auto_cd auto_pushd pushd_ignore_dups pushdminus
setopt PROMPT_SUBST

bindkey -v
bindkey -s -- '--' '_'
```

The `cdpath` variable is one of Zsh's most underrated features.
With this setting, I can type `cd myproject` from anywhere and
Zsh will search `~/Dropbox/prj/myproject` automatically. Combined
with `auto_cd` (which lets me omit `cd` entirely and just type
a directory name), navigation becomes remarkably fast.

The `auto_pushd` option maintains a directory stack that I can
navigate with numbered aliases (`1`, `2`, `3`, etc.) defined
later. `PROMPT_SUBST` enables variable expansion in the prompt.

I use vi mode (`bindkey -v`) because my muscle memory expects
hjkl navigation and Escape to exit insert mode. The `--` to `_`
binding is a small convenience: typing two hyphens produces an
underscore, which is faster for snake_case identifiers.

### History Management

```sh
HISTFILE="$HOME/.zsh_history"
HISTSIZE=100000
SAVEHIST=100000
setopt SHARE_HISTORY HIST_IGNORE_DUPS INC_APPEND_HISTORY HIST_VERIFY
```

I keep 100,000 lines of history because disk space is cheap and
I frequently need to recall commands from weeks ago. The options
work together:

- `SHARE_HISTORY` syncs history across all terminal sessions in
  real time (controversial -- some people find this disorienting)
- `HIST_IGNORE_DUPS` avoids cluttering history with repeated
  commands
- `INC_APPEND_HISTORY` writes each command immediately rather
  than at session end
- `HIST_VERIFY` shows the expanded command before executing when
  using history substitution (e.g., `!!`), giving me a chance to
  review before running

### Completion System

```sh
autoload -Uz compinit
if [[ -n ${ZDOTDIR}/.zcompdump(#qN.mh+24) ]]; then
    compinit
else
    compinit -C
fi
compdef _dirs d
```

The completion system is one of Zsh's strengths, but initialising
it on every shell startup adds latency. This code caches the
completion dump file and only regenerates it if it is more than
24 hours old. The result is noticeably faster shell startup.

The `compdef _dirs d` line tells Zsh to use directory completion
for my custom `d` function defined later.

### Prompt and Git Integration

```sh
autoload -Uz vcs_info
precmd() { vcs_info }
zstyle ':vcs_info:git:*' formats '%b '

PROMPT='%F{cyan}%m%f %F{green}%*%f %F{yellow}${${PWD:A}/$HOME/~}%f %F{red}${vcs_info_msg_0_}%f$ %(?:☕  :☔  )'
```

This prompt displays:

- Hostname in cyan (useful when SSHing between machines)
- Current time in green
- Working directory in yellow (with `~` substituted for `$HOME`)
- Git branch in red (via `vcs_info`)
- A coffee cup if the last command succeeded, a rain cloud if it
  failed

The `vcs_info` approach is lightweight compared to Oh My Zsh's
git plugin. It runs in the `precmd` hook before each prompt and
extracts just the branch name. This has saved me from committing
to the wrong branch countless times.

### Plugin Management

```sh
if [[ "$OSTYPE" == "linux-gnu"* ]]; then
    [[ -s /home/z/.autojump/etc/profile.d/autojump.sh ]] && source /home/z/.autojump/etc/profile.d/autojump.sh
    [[ -f ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh ]] && source ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh
    [[ -f ~/.zsh/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh ]] && source ~/.zsh/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
elif [[ "$OSTYPE" == "darwin"* ]]; then
    if [[ -z "$BREW_PREFIX" ]]; then
        export BREW_PREFIX="/opt/homebrew"
    fi
    [[ -f "$BREW_PREFIX/etc/profile.d/autojump.sh" ]] && source "$BREW_PREFIX/etc/profile.d/autojump.sh"
    [[ -f "$BREW_PREFIX/share/zsh-autosuggestions/zsh-autosuggestions.zsh" ]] && source "$BREW_PREFIX/share/zsh-autosuggestions/zsh-autosuggestions.zsh"
    [[ -f "$BREW_PREFIX/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh" ]] && source "$BREW_PREFIX/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh"
fi

ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=red,bold,underline'
```

I use three plugins, each addressing a specific friction point
in command-line work:

**autojump** maintains a database of directories you visit,
weighted by frequency. After using it for a few days, you can
type `j proj` to jump to `~/Dropbox/prj/myproject` without
typing the full path. It learns from your behaviour: the more
often you visit a directory, the higher it ranks in fuzzy
matching. Install with `brew install autojump` (macOS) or
`apt install autojump` (Ubuntu). The only downside is the
initial learning period -- it takes a week or two of normal
usage before the database becomes useful.

**zsh-autosuggestions** displays ghost text showing a prediction
of what you might type next, based on your command history. As
you type `git`, it might suggest `git status` in grey text. Press
the right arrow key to accept the entire suggestion, or press
`Ctrl+E` to accept just to the end of the current word. This
plugin has dramatically reduced my typing for repetitive
commands. Install with `brew install zsh-autosuggestions`
(macOS) or clone from GitHub on Linux. The
`ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE` setting controls how
suggestions appear; I use red bold underline to make them
visually distinct from my actual typing.

**zsh-syntax-highlighting** provides real-time syntax
highlighting as you type. Valid commands appear in green,
unknown commands in red, quoted strings in yellow, and paths
that exist are underlined. This catches typos before you press
Enter: if `git comit` appears in red, you know immediately that
it is not a valid command. Install with
`brew install zsh-syntax-highlighting` (macOS) or clone from
GitHub on Linux. Note that this plugin must be sourced last in
your `.zshrc` to work correctly with other plugins.

The conditional loading pattern (`[[ -f ... ]] && source ...`)
means Zsh will not error if a plugin is missing. This is
essential for sharing the same `.zshrc` across machines where
not all plugins are installed. If autojump is not present, that
line does nothing and the shell continues to load.

On macOS, I cache `BREW_PREFIX` to avoid calling `brew --prefix`
on every shell startup. Without caching, `brew --prefix` adds
roughly 200-400ms to shell startup time, which is noticeable
when opening new terminal tabs. Hardcoding `/opt/homebrew`
(the default on Apple Silicon Macs) eliminates this delay.

### FZF Configuration

```sh
if type rg &> /dev/null; then
    export FZF_DEFAULT_COMMAND='rg --files --hidden'
    export FZF_DEFAULT_OPTS='-m --height 50% --border --reverse'
fi
```

This configures `fzf` (fuzzy finder) to use `ripgrep` as its file
source, but only if `ripgrep` is installed. The options enable
multi-select (`-m`), use half the terminal height, add a border,
and reverse the list so matches appear at the bottom near the
prompt.

### Navigation Aliases

```sh
alias -- -='cd -'
alias -g ...='../..'

alias 1='cd -1'
alias 2='cd -2'
alias 3='cd -3'
alias 4='cd -4'
alias 5='cd -5'
```

The `-` alias lets me type just `-` to return to the previous
directory. The `...` global alias expands to `../..` anywhere in
a command. The numbered aliases navigate the directory stack
maintained by `auto_pushd`.

### File Listing with Colour

```sh
if [[ "$OSTYPE" == "darwin"* ]]; then
    if command -v gls &> /dev/null; then
        alias ls='gls --color=auto'
        alias ll='gls -lh --color=auto'
    else
        alias ls='ls -G'
        alias ll='ls -lhG'
    fi
else
    alias ls='ls --color=auto'
    alias ll='ls -lh --color=auto'
fi

alias lt='eza -lrha -sold'
alias grep='grep --color=auto'
```

macOS ships with BSD `ls`, which uses `-G` for colour. Linux
uses GNU `ls`, which uses `--color=auto`. If I have installed
GNU coreutils on macOS (via `brew install coreutils`), I prefer
`gls` for consistency. The `lt` alias uses `eza` (a modern `ls`
replacement) to list files sorted by modification time.

### Application Shortcuts

```sh
alias za='zathura'
alias hh='history'
alias R='R --quiet --no-save'
alias mm='mutt'
alias v='vim'
alias ZZ='exit'

alias vc='vim ~/.config/vim/vimrc'
alias vz='vim ~/Dropbox/dotfiles/zshrc'
alias sz='source ~/.zshrc'
```

These are simple shortcuts for programs I use frequently. The
`R` alias starts R without the startup message and without
prompting to save the workspace on exit. `ZZ` mirrors vim's exit
command. The config editing aliases (`vc`, `vz`, `sz`) make it
fast to edit and reload configuration files.

### Safety Aliases

```sh
alias tp='trash-put -v'
# alias rm='echo "This is not the command you are looking for."; false'
```

After accidentally deleting a dataset early in my career, I
adopted `trash-put` from the `trash-cli` package. The `tp` alias
moves files to the trash rather than deleting them permanently.
I keep the `rm` override commented out because it breaks scripts
that legitimately need to delete files, but uncommenting it
provides an extra safety net during interactive use.

### Fuzzy Finding Functions

```sh
d() {
    if [[ -n $1 ]]; then
        dirs "$@"
    else
        dirs -v | head -n 10
    fi
}

ff() {
    local file
    file=$(rg --files "${1:-.}" 2>/dev/null | fzf --select-1 --exit-0)
    if [[ -n "$file" ]]; then
        cd "$(dirname "$file")" || return 1
    fi
}

pp() {
    local pdf
    pdf=$(rg --files 2>/dev/null | rg "\.pdf$" | fzf)
    if [[ -n "$pdf" ]]; then
        zathura "$pdf" &
    fi
}

rr() {
    local rfile
    rfile=$(rg --files 2>/dev/null | rg "\.(R|Rmd)$" | fzf)
    if [[ -n "$rfile" ]]; then
        vim "$rfile"
    fi
}
```

These functions combine `ripgrep` with `fzf` for rapid file
navigation:

- `d` shows the directory stack (up to 10 entries)
- `ff` finds any file and `cd`s to its directory
- `pp` finds PDF files and opens them in Zathura
- `rr` finds R or Rmd files and opens them in vim

The pattern is consistent: use `ripgrep` to list files, pipe to
`fzf` for selection, then take action on the result. These
functions have largely replaced my use of graphical file managers.

### Git Workflow Function

```sh
gz() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        echo "Error: Not a git repository" >&2
        return 1
    fi

    echo "Current git status:"
    git status --short
    echo ""

    git add .

    echo "═══════════════════════════════════════════════════════════"
    git diff --cached --stat
    echo ""
    git diff --cached | head -30
    echo ""

    local summary=$(git diff --cached --name-only | head -5 | tr '\n' ', ' | sed 's/,$//')
    local file_count=$(git diff --cached --name-only | wc -l)
    if [[ $file_count -gt 5 ]]; then
        summary="$summary and $((file_count - 5)) more files"
    fi

    echo "Commit type:"
    echo "  1) feat   2) fix   3) refactor   4) docs   5) test"
    echo "  6) chore  7) perf  8) ci         9) style"
    echo -n "Select (1-9): "
    read type_choice

    case $type_choice in
        1) local type="feat" ;;
        2) local type="fix" ;;
        3) local type="refactor" ;;
        4) local type="docs" ;;
        5) local type="test" ;;
        6) local type="chore" ;;
        7) local type="perf" ;;
        8) local type="ci" ;;
        9) local type="style" ;;
        *) local type="chore" ;;
    esac

    echo -n "Scope (optional): "
    read scope
    echo -n "Description (optional): "
    read description

    local commit_msg="$type"
    [[ -n "$scope" ]] && commit_msg="$commit_msg($scope)"
    commit_msg="$commit_msg: $summary"
    [[ -n "$description" ]] && commit_msg="$commit_msg"$'\n\n'"$description"

    git commit -m "$commit_msg"
    [[ $? -ne 0 ]] && return 1

    git push
}
```

The `gz` function implements a guided git workflow: stage all
changes, show a summary, prompt for a conventional commit type
and optional scope, generate a commit message, and push. This
enforces consistent commit message formatting without requiring
me to remember the exact syntax each time.

### External Tool Integration

```sh
export NVM_DIR="$HOME/.nvm"
[[ -s "$NVM_DIR/nvm.sh" ]] && \. "$NVM_DIR/nvm.sh"
[[ -s "$NVM_DIR/bash_completion" ]] && \. "$NVM_DIR/bash_completion"

if [[ "$OSTYPE" == "darwin"* ]]; then
    if [[ -z "$DISPLAY" ]]; then
        export DISPLAY=:0
    fi
fi
```

NVM (Node Version Manager) is loaded conditionally. The
`DISPLAY` variable setup is for running GUI applications inside
Docker containers on macOS via XQuartz.

### Conda Initialization

```sh
if [[ "$OSTYPE" == "darwin"* ]]; then
    _CONDA_ROOT="/opt/miniconda3"
elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
    _CONDA_ROOT="$HOME/miniconda3"
fi

__conda_setup="$('/opt/miniconda3/bin/conda' 'shell.zsh' 'hook' 2> /dev/null)"
if [ $? -eq 0 ]; then
    eval "$__conda_setup"
else
    if [ -f "/opt/miniconda3/etc/profile.d/conda.sh" ]; then
        . "/opt/miniconda3/etc/profile.d/conda.sh"
    else
        export PATH="/opt/miniconda3/bin:$PATH"
    fi
fi
unset __conda_setup
```

This block is generated by `conda init` and handles setting up
the Conda environment. I have kept the paths platform-aware,
though the initialization block itself uses hardcoded paths that
would need editing on a different machine.

### Project Navigation (ZZCOLLAB)

```sh
_zzcollab_root() {
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -f "$dir/DESCRIPTION" ]] || [[ -f "$dir/.zzcollab_project" ]]; then
            echo "$dir"
            return 0
        fi
        dir="$(dirname "$dir")"
    done
    return 1
}

a() { local root=$(_zzcollab_root); [[ -n "$root" ]] && cd "$root/analysis" || echo "Not in ZZCOLLAB project"; }
s() { local root=$(_zzcollab_root); [[ -n "$root" ]] && cd "$root/analysis/scripts" || echo "Not in ZZCOLLAB project"; }
p() { local root=$(_zzcollab_root); [[ -n "$root" ]] && cd "$root/analysis/report" || echo "Not in ZZCOLLAB project"; }
f() { local root=$(_zzcollab_root); [[ -n "$root" ]] && cd "$root/analysis/figures" || echo "Not in ZZCOLLAB project"; }
r() { local root=$(_zzcollab_root); [[ -n "$root" ]] && cd "$root/R" || echo "Not in ZZCOLLAB project"; }
0() { local root=$(_zzcollab_root); [[ -n "$root" ]] && cd "$root" || echo "Not in ZZCOLLAB project"; }

mr() {
    local root=$(_zzcollab_root)
    [[ -z "$root" ]] && echo "Not in ZZCOLLAB project" && return 1
    [[ ! -f "$root/Makefile" ]] && echo "No Makefile in: $root" && return 1
    make -C "$root" "${@:-r}"
}
```

These functions support my research compendium workflow. From
anywhere inside a project, single-letter commands navigate to
standard directories: `a` for analysis, `s` for scripts, `p` for
the report, `f` for figures, `r` for R source files, and `0` for
the project root. The `mr` function runs Make targets from any
subdirectory.

The `_zzcollab_root` helper walks up the directory tree looking
for a `DESCRIPTION` file (standard R package marker) or a
`.zzcollab_project` file (my project marker). This pattern lets
me define project-aware commands without hardcoding paths.

---

The numbered sections are deliberate. When I need to add a new
alias, I go straight to the aliases section. When a plugin
breaks, I look at plugin management. This organisational
discipline saves time every time I edit the file.

## Git Configuration

Git is central to the workflow described above -- the `gz`
function, the branch display in the prompt, and general version
control. The configuration lives in `~/.gitconfig`.

`~/.gitconfig`:

### User Identity and Defaults

```ini
[init]
    defaultBranch = main

[user]
    name = r. glenn thomas
    email = rgthomas@ucsd.edu

[core]
    editor = nvim
    excludesfile = ~/.gitignore_global
```

The `defaultBranch` setting ensures new repositories start with
`main` rather than `master`. The `excludesfile` points to a
global gitignore that applies to all repositories -- useful for
editor backup files, OS metadata like `.DS_Store`, and other
files that should never be committed regardless of project.

### Pull and Merge Behaviour

```ini
[pull]
    rebase = false

[commit]
    quiet = true
```

I use `rebase = false` to preserve merge commits when pulling.
Some teams prefer `rebase = true` for a linear history, but I
find merge commits useful for understanding when changes were
integrated. The `quiet = true` setting suppresses the commit
summary output, which I find redundant given the `gz` function
already shows what was committed.

### GitHub Authentication

```ini
[credential "https://github.com"]
    helper =
    helper = !/opt/homebrew/bin/gh auth git-credential

[credential "https://gist.github.com"]
    helper =
    helper = !/opt/homebrew/bin/gh auth git-credential
```

Rather than managing SSH keys or personal access tokens
manually, I delegate authentication to the GitHub CLI (`gh`).
After running `gh auth login` once, Git uses `gh` as a
credential helper for all GitHub operations. The empty `helper =`
line clears any previously configured helpers before adding the
`gh` helper.

### Git LFS

```ini
[filter "lfs"]
    clean = git-lfs clean -- %f
    smudge = git-lfs smudge -- %f
    process = git-lfs filter-process
    required = true
```

Git LFS (Large File Storage) handles binary files like datasets,
images, and model weights. This block is added automatically by
`git lfs install`. Files matching patterns in `.gitattributes`
are stored externally and replaced with pointers in the
repository, keeping the repository size manageable.

### Useful Additions

The configuration above is minimal. Consider adding:

```ini
[alias]
    st = status --short
    co = checkout
    br = branch
    lg = log --oneline --graph --decorate -20

[diff]
    colorMoved = default

[merge]
    conflictstyle = diff3
```

The `lg` alias provides a compact visual history. The
`colorMoved` setting highlights moved lines in diffs (useful
when refactoring). The `diff3` conflict style shows the common
ancestor in merge conflicts, making resolution easier.

## Readline Configuration

Many command-line tools -- including R, Python's REPL, and
various database clients -- use the GNU Readline library for
line editing. By default, Readline uses Emacs-style keybindings,
which conflicts with the vi mode configured in Zsh. The
`.inputrc` file brings consistency across all Readline-based
tools.

`~/.inputrc`:

```sh
set editing-mode vi
set show-mode-in-prompt on
set vi-ins-mode-string \1\e[6 q\2
set vi-cmd-mode-string \1\e[2 q\2
```

The `editing-mode vi` setting enables vi keybindings globally.
The mode indicator settings change the cursor shape to signal
which mode you are in: a thin bar in insert mode, a solid block
in command mode. This matches the behaviour of many modern
terminal-based editors.

### Enhanced Completion

```sh
set completion-ignore-case on
set show-all-if-ambiguous on
set colored-stats on
set mark-symlinked-directories on
```

Case-insensitive completion reduces friction when working with
mixed-case filenames. The `show-all-if-ambiguous` setting
displays all matches immediately rather than requiring a second
Tab press. Coloured stats distinguish files from directories in
completion lists, and symlinked directories get a trailing slash
for clarity.

### History Navigation

```sh
set history-preserve-point on
"\e[A": history-search-backward
"\e[B": history-search-forward
```

The `history-preserve-point` setting keeps the cursor position
when navigating history. The key bindings make the up and down
arrows search history for commands starting with whatever you
have already typed -- the same behaviour as Zsh's
history-substring-search.

### Bell and Display

```sh
set bell-style none
set enable-bracketed-paste on
```

I disable the terminal bell because I find it disruptive. The
bracketed paste setting prevents pasted text from being
interpreted as commands until you press Enter, which is a
security feature when pasting from untrusted sources.

---

With these four configuration files -- `kitty.conf`, `.zshrc`,
`.gitconfig`, and `.inputrc` -- the command-line environment
becomes consistent and efficient across all tools.

# Putting It Together: A Typical Session

With the configuration in place, here is what a typical work
session looks like:

1. I open Kitty and type `prj` (thanks to `cdpath`, this
   expands to `~/Dropbox/prj`)
2. I type `j analysis` and autojump takes me to my most recent
   analysis project
3. I type `0` to jump to the project root, then `s` for scripts
4. I type `rr`, fzf shows me all R files, I select one and it
   opens in vim
5. After editing, I type `gz` to stage, commit with a
   conventional message, and push
6. If I need to check a plot, `pp` finds and opens the PDF

The individual pieces -- cdpath, autojump, fzf functions, the
git workflow -- each save a few seconds. Over hundreds of
commands per day, the cumulative effect is significant.

# Checking Our Work: Verifying the Configuration

After copying these configuration files into place, it is worth
verifying that everything loaded correctly.

**Check Kitty settings:**

```bash
kitty --version
kitty +kitten themes --list
```

The first command confirms Kitty is installed. The second lists
available themes, which verifies that the Kitty kitten system is
working.

**Check Zsh and plugins:**

```bash
zsh --version
echo $SHELL
which autojump 2>/dev/null && echo "autojump: loaded" \
  || echo "autojump: not found"
type fzf 2>/dev/null && echo "fzf: loaded" \
  || echo "fzf: not found"
```

**Verify the prompt shows git information:**

```bash
cd /path/to/any/git/repo
# The prompt should display the branch name in red
```

**Test safety aliases:**

```bash
rm test.txt
# Expected output: "This is not the command you are
#   looking for."
```

If any plugin fails to load, the `[[ -f ... ]] && source ...`
guards in section 6 mean Zsh will continue without error. This
is deliberate: I would rather have a working shell with a
missing plugin than a broken shell.

## Things to Watch Out For

1. **Duplicate key bindings.** I initially defined the same
   Kitty keybinding in both the basic and data-science sections
   of my config. Kitty uses the last definition, so the earlier
   one was silently ignored. Merge your config into one file to
   avoid this.

2. **Plugin startup cost.** Loading `zsh-syntax-highlighting`,
   `zsh-autosuggestions`, and `autojump` adds roughly 100-200ms
   to shell startup. If you notice lag when opening new
   terminals, profile with `zsh -xv` and consider lazy-loading.

3. **`cdpath` collisions.** If two directories in your `cdpath`
   contain subdirectories with the same name, Zsh picks the
   first match. I once spent twenty minutes wondering why `cd
   data` took me to the wrong project.

4. **Conda and PATH pollution.** The conda initialisation block
   modifies `$PATH` every time a shell starts. If you open many
   terminal tabs, check that `$PATH` has not accumulated
   duplicate entries with `echo $PATH | tr ':' '\n' | sort |
   uniq -d`.

5. **Font fallback on Linux.** FiraCode Nerd Font Mono must be
   installed system-wide on Linux for Kitty to find it. If
   prompt icons render as boxes, run `fc-list | grep -i fira` to
   verify the font is visible to fontconfig.

![A lofi aesthetic workspace with warm lighting and a laptop
screen](media/images/ambiance3.jpg){.img-fluid}

*The calm focus of a well-tuned workspace -- what a
thoughtfully configured terminal makes possible.*

## Lessons Learnt

### Conceptual Understanding

- A terminal configuration is a layered system: the emulator
  (Kitty) handles rendering and input; the shell (Zsh) handles
  commands, history, and scripting. Configuring them separately
  keeps each layer clean.
- Scrollback and performance settings are not cosmetic. A
  50,000-line buffer and zero input delay make a tangible
  difference when reviewing long model outputs.
- Directory navigation is a solved problem in Zsh. Between
  `cdpath`, `auto_pushd`, and `autojump`, there is no reason to
  type full paths.
- The prompt is an information display, not decoration. Showing
  git branch and exit status prevents real errors.

### Technical Skills

- I learnt to use `vcs_info` for lightweight git integration in
  the prompt, avoiding the overhead of Oh My Zsh.
- Cross-platform plugin loading via `$OSTYPE` checks lets me
  share one `.zshrc` between macOS and Linux.
- Combining `ripgrep` with `fzf` for file finding (the `pp`,
  `rr`, and `ff` functions) replaced several GUI tools I used
  to depend on.
- Kitty's remote control API (`kitty @`) opens possibilities
  for scripting terminal layouts, which I use when setting up
  experiment monitoring.

### Gotchas and Pitfalls

- Overriding `rm` with a safety alias means scripts that call
  `rm` will also fail. Use `command rm` or `/bin/rm` in scripts
  when you genuinely need to delete.
- `setopt SHARE_HISTORY` shares history across all terminal
  sessions in real time, which can be disorienting if you are
  not expecting it.
- The `_load_plugin` helper function defined in section 6 is
  currently unused because I found inline conditionals more
  readable for three plugins. It would become useful with more
  plugins.
- Kitty's `background_image` setting accepts an absolute path.
  If the image file moves, Kitty starts with a black background
  and no error message.

## Limitations

- This configuration is tested only on macOS (Sonoma) and
  Ubuntu 22.04. Other distributions may require different
  plugin paths or package names.
- The `.zshrc` includes hardcoded paths (e.g.,
  `/opt/miniconda3`, `/home/z/.autojump`) that will not work
  on other machines without editing.
- The Kitty configuration references a background image at an
  absolute path that is specific to my machine.
- Plugin loading adds startup latency. For remote servers where
  shell startup time matters (e.g., inside Docker containers),
  a stripped-down `.zshrc` would be more appropriate.
- The `cdpath` approach does not scale well to deeply nested
  project structures with many similarly-named subdirectories.
- No automated testing or linting is applied to these
  configuration files. A typo in `.zshrc` is only caught when
  the shell starts.

## Opportunities for Improvement

1. Store the configuration in a dotfiles repository with a
   symlink-based installer (see my companion post on GitHub
   dotfiles).
2. Replace hardcoded paths with environment variables or
   auto-detection logic to improve portability.
3. Add lazy-loading for plugins to reduce shell startup time
   below 50ms.
4. Integrate with a tiling window manager (Rectangle on macOS,
   i3/Sway on Linux) to automate window positioning alongside
   terminal splits.
5. Add Karabiner-Elements (macOS) or custom keybindings (Linux)
   for a global hotkey to summon Kitty instantly.
6. Write a shell function that profiles `.zshrc` startup time
   and identifies slow sections automatically.

# Wrapping Up

Configuring a terminal is not glamorous work, but it compounds.
Every alias that saves two seconds, every prompt element that
prevents a mistake, and every navigation shortcut that avoids a
full path -- they add up across thousands of commands per week.

What I found most valuable was the organisational discipline:
ten numbered sections in `.zshrc`, one merged `kitty.conf`, and
a clear separation between the terminal emulator and the shell.
When something breaks, I know exactly where to look. When I want
to add something new, I know exactly where to put it.

If you are starting from a default terminal setup, I would
suggest focusing on three things first: a Nerd Font for icon
support, `cdpath` for directory navigation, and `fzf` for fuzzy
file finding. Those three changes alone made the biggest
difference in my daily workflow.

**Main takeaways:**

- A 50,000-line scrollback buffer prevents losing model training
  output.
- `cdpath` and `auto_pushd` eliminate most `cd ../../..` chains.
- Replacing `rm` with a trash alias prevents accidental data
  loss.
- Cross-platform plugin loading via `$OSTYPE` keeps one `.zshrc`
  working on both macOS and Linux.

# See Also

**Related posts:**

- [Creating a GitHub Dotfiles Repository for Configuration
  Management](/posts/24-setupdotfilesongithub/) -- how to
  version-control the files described in this post
- [Setting Up Neovim for Data Science
  Development](/posts/12-configneovim/) -- the editor layer
  that sits on top of this terminal configuration

**Key resources:**

- [Kitty Terminal Documentation](https://sw.kovidgoyal.net/kitty/)
  -- the official reference for all configuration options
- [Zsh Documentation](https://zsh.sourceforge.io/Doc/) --
  official manual covering options, completion, and scripting
- [FZF](https://github.com/junegunn/fzf) -- the fuzzy finder
  used throughout this configuration
- [Ripgrep](https://github.com/BurntSushi/ripgrep) -- the
  search tool that powers `fzf` file finding here
- [Configuring Zsh Without Dependencies](https://thevaluable.dev/zsh-install-configure-mouseless/)
  -- an excellent guide to building a Zsh config from scratch

# Reproducibility

**Environment requirements:**

- macOS 10.15+ or Linux (Ubuntu 18.04+, Fedora 30+)
- Zsh 5.0+, Git, Homebrew (macOS)
- FiraCode Nerd Font Mono
- Optional: `fzf`, `ripgrep`, `eza`, `autojump`, `trash-cli`

**Configuration file locations:**

- Kitty: `~/.config/kitty/kitty.conf`
- Zsh: `~/.zshrc`
- Environment secrets: `~/.env` (not version-controlled)

**Version checks:**

```bash
zsh --version
kitty --version
brew --version    # macOS only
fzf --version
rg --version
```

# Let's Connect

- **GitHub**: [rgt47](https://github.com/rgt47)
- **Twitter/X**: [@rgt47](https://twitter.com/rgt47)
- **LinkedIn**: [Ronald Glenn Thomas](https://linkedin.com/in/rgthomaslab)
- **Email**: [Contact through website](https://rgtlab.org/contact)

I would enjoy hearing from you if you:

- Spot an error or have a correction
- Have a better approach to any of these configurations
- Want to share your own terminal setup
- Have questions about adapting this for a specific workflow
- Just want to connect and talk about command-line tools
